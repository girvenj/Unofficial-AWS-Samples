resource "aws_ssm_document" "ssm_baseline" {
  name            = "SSM-Baseline-${var.ssm_docs_random_string}"
  document_format = "JSON"
  document_type   = "Automation"
  content         = <<DOC
    {
      "schemaVersion": "0.3",
      "description": "Deploy AD with SSM Automation",
      "parameters": {
        "FsxOnpremAdmins": {
          "default": "placeholder",
          "description": "The name of the domain group whose members are granted administrative privileges for the file system",
          "type": "String"
        },
        "ServerRole": {
          "description": "Role server will be (DomainController or CertificateAuthority)",
          "type": "String"
        },
        "TrustDirection": {
          "default": "placeholder",
          "description": "Trust Direction from AWS Managed Microsoft AD to on-premises domain.",
          "type": "String"
        },
        "DomainDNSName": {
          "description": "Fully qualified domain name (FQDN) of the forest root domain e.g. onpremises.local",
          "type": "String"
        },
        "MadDirectoryID": {
          "default": "placeholder",
          "description": "Directory ID of MAD domain",
          "type": "String"
        },
        "DomainNetBIOSName": {
          "default": "placeholder",
          "description": "NetBIOS name of the domain (up to 15 characters) for users of earlier versions of Windows e.g. ONPREMISES",
          "type": "String"
        },
        "FsxOnpremParentOu": {
          "default": "placeholder",
          "description": "Parent OU DN for Amazon FSX for Windows deployment with On-Premises AD",
          "type": "String"
        },
        "DeploymentType": {
          "description": "Type of workload being deployed",
          "type": "String"
        },
        "TrustSecretName": {
          "default": "placeholder",
          "description": "AWS Secrets Parameter Name",
          "type": "String"
        },
        "ServerNetBIOSName": {
          "description": "NetBIOS name of the first Active Directory Domain Controller (up to 15 characters)",
          "type": "String"
        },
        "LogicalResourceId": {
          "description": "CloudFormation Resource ID",
          "type": "String"
        },
        "DomainType": {
          "default": "placeholder",
          "description": "Type of domain PKI will be integrated with",
          "type": "String"
        },
        "MadDNSName": {
          "default": "placeholder",
          "description": "Fully qualified domain name (FQDN) of the MAD domain e.g. corp.example.com",
          "type": "String"
        },
        "VPCCIDR": {
          "description": "CIDR Block for the VPC",
          "type": "String"
        },
        "ParentDomainDNSName": {
          "default": "placeholder",
          "description": "Fully qualified domain name (FQDN) of the forest root domain e.g. onpremises.local",
          "type": "String"
        },
        "AdministratorSecretName": {
          "description": "AWS Secrets Parameter Name",
          "type": "String"
        },
        "FsxOnpremSvcUn": {
          "default": "placeholder",
          "description": "The user name for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain",
          "type": "String"
        },
        "IntegrateFsxOnprem": {
          "default": "placeholder",
          "description": "Deploy & Integrate Amazon FSX for Windows with On-Premises AD",
          "type": "String"
        },
        "DeployPki": {
          "description": "Deploy an Enterprise CA",
          "type": "String"
        },
        "FsxOnpremSvcSecret": {
          "default": "placeholder",
          "description": "The secret containing the password for the service account on your self-managed AD domain that Amazon FSx will use to join to your AD domain",
          "type": "String"
        },
        "OnpremDomainDNSName": {
          "default": "placeholder",
          "description": "Fully qualified domain name (FQDN) of the forest root domain e.g. example.com",
          "type": "String"
        },
        "StackName": {
          "description": "Stack Name Input for cfn resource signal",
          "type": "String"
        },
        "ParentInstanceIP": {
          "default": "placeholder",
          "description": "IP Address of the forest root domain controller",
          "type": "String"
        }
      },
      "mainSteps": [
        {
          "outputs": [
            {
              "Type": "String",
              "Name": "InstanceId",
              "Selector": "$.Reservations[0].Instances[0].InstanceId"
            }
          ],
          "inputs": {
            "Filters": [
              {
                "Values": [
                  "{{ServerNetBIOSName}}"
                ],
                "Name": "tag:Name"
              },
              {
                "Values": [
                  "{{StackName}}"
                ],
                "Name": "tag:aws:cloudformation:stack-name"
              },
              {
                "Values": [
                  "running"
                ],
                "Name": "instance-state-name"
              }
            ],
            "Service": "ec2",
            "Api": "DescribeInstances"
          },
          "name": "InstanceId",
          "action": "aws:executeAwsApi",
          "onFailure": "step:signalFailure",
          "nextStep": "intializeInstance"
        },
        {
          "inputs": {
            "Parameters": {
              "commands": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\n\n$RegistryItems = @(\n    @{\n        Name         = 'SchUseStrongCrypto'\n        Path         = 'Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\.NETFramework\\v4.0.30319'\n        Value        = '1'\n        PropertyType = 'DWORD'\n    },\n    @{\n        Name         = 'SchUseStrongCrypto'\n        Path         = 'Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\.NETFramework\\v4.0.30319'\n        Value        = '1'\n        PropertyType = 'DWORD'\n    }\n)\n\nForeach ($RegistryItem in $RegistryItems) {\n    Try {\n        $Null = New-ItemProperty @RegistryItem -Force -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed to create Registry key named $($RegistryItem.Name) at $($RegistryItem.Path) $_\"\n        Exit 1\n    }\n}\n\n$Modules = @(\n    @{\n        Name    = 'NetworkingDsc'\n        Version = '9.0.0'\n    },\n    @{\n        Name    = 'ActiveDirectoryDsc'\n        Version = '6.2.0'\n    },\n    @{\n        Name    = 'ComputerManagementDsc'\n        Version = '8.5.0'\n    },\n    @{\n        Name    = 'DnsServerDsc'\n        Version = '3.0.0'\n    },\n    @{\n        Name    = 'AuditPolicyDsc'\n        Version = '1.4.0.0'\n    },\n    @{\n        Name    = 'SChannelDsc'\n        Version = '1.4.0'\n    }\n)\n\nFunction New-VolumeFromRawDisk {\n    Write-Output 'Finding RAW Disk'\n    $Counter = 0\n    Do {\n        Try {\n            $BlankDisks = Get-Disk -ErrorAction Stop | Where-Object { $_.PartitionStyle -eq 'RAW' } | Select-Object -ExpandProperty 'Number'\n        } Catch [System.Exception] {\n            Write-Output \"Failed to get disk $_\"\n            $BlankDisks = $Null\n        }\n        If (-not $BlankDisks) {\n            $Counter ++\n            Write-Output 'RAW Disk not found sleeping 10 seconds and will try again.'\n            Start-Sleep -Seconds 10\n        }\n    } Until ($BlankDisks -or $Counter -eq 12)\n\n    If ($Counter -ge 12) {\n        Write-Output 'RAW Disk not found exiting'\n        Return\n    }\n\n    Foreach ($BlankDisk in $BlankDisks) {\n        Write-Output 'Data Volume not initialized attempting to bring online'\n        Try {\n            Initialize-Disk -Number $BlankDisk -PartitionStyle 'GPT' -ErrorAction Stop\n        } Catch [System.Exception] {\n            Write-Output \"Failed attempting to bring online Data Volume $_\"\n            Exit 1\n        }\n\n        Start-Sleep -Seconds 5\n\n        Write-Output 'Data Volume creating new partition'\n        Try {\n            $DriveLetter = New-Partition -Alignment '4096000' -DiskNumber $BlankDisk -AssignDriveLetter -UseMaximumSize -ErrorAction Stop | Select-Object -ExpandProperty 'DriveLetter'\n        } Catch [System.Exception] {\n            Write-Output \"Failed creating new partition $_\"\n            Exit 1\n        }\n\n        Start-Sleep -Seconds 5\n\n        Write-Output 'Data Volume formatting partition'\n        Try {\n            $Null = Format-Volume -DriveLetter $DriveLetter -FileSystem 'NTFS' -NewFileSystemLabel 'Data' -Confirm:$false -Force -ErrorAction Stop\n        } Catch [System.Exception] {\n            Write-Output \"Failed formatting partition $_\"\n            Exit 1\n        }\n\n        Try {\n            $Null = Get-CimInstance -ClassName 'Win32_Volume' -Filter \"DriveLetter='$($DriveLetter):'\" -ErrorAction Stop | Set-CimInstance -Arguments @{ IndexingEnabled = $False }\n        } Catch [System.Exception] {\n            Write-Output \"Failed to turn off indexing $_\"\n            Exit 1\n        }\n    }\n}\n\nFunction Invoke-PreConfig {\n    Write-Output 'Temporarily disabling Windows Firewall'\n    Try {\n        Get-NetFirewallProfile -ErrorAction Stop | Set-NetFirewallProfile -Enabled False -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed to disable Windows Firewall $_\"\n        Exit 1\n    }\n\n    $Dirs = @(\n        'C:\\Temp\\publickeys',\n        'C:\\DnsLogs'\n    )\n\n    Foreach ($Dir in $Dirs) {\n        Write-Output \"Creating file directory $Dir\"\n        Try {\n            $Null = New-Item -Path $Dir -ItemType 'Directory' -ErrorAction Stop\n        } Catch [System.Exception] {\n            Write-Output \"Failed to create directory $Dir $_\"\n            Exit 1\n        }\n    }\n\n    Write-Output 'Creating certificate to encrypt credentials in MOF file'\n    Try {\n        $cert = New-SelfSignedCertificate -Type 'DocumentEncryptionCertLegacyCsp' -DnsName 'DscEncryptCert' -HashAlgorithm 'SHA256' -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed to create self signed cert $_\"\n        Exit 1\n    }\n\n    Write-Output 'Exporting the self signed public key certificate'\n    Try {\n        $Null = $cert | Export-Certificate -FilePath 'C:\\Temp\\publickeys\\DscPublicKey.cer' -Force -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed to copy self signed cert to publickeys directory $_\"\n        Exit 1\n    }\n}\n\nFunction Invoke-LcmConfig {\n    Write-Output 'Getting the DSC cert thumbprint to secure the MOF file'\n    Try {\n        $DscCertThumbprint = Get-ChildItem -Path 'cert:\\LocalMachine\\My' -ErrorAction Stop | Where-Object { $_.Subject -eq 'CN=DscEncryptCert' } | Select-Object -ExpandProperty 'Thumbprint'\n    } Catch [System.Exception] {\n        Write-Output \"Failed to get DSC cert thumbprint $_\"\n        Exit 1\n    }\n\n    [DSCLocalConfigurationManager()]\n    Configuration LCMConfig\n    {\n        Node 'localhost' {\n            Settings {\n                RefreshMode                    = 'Push'\n                ConfigurationModeFrequencyMins = 15\n                ActionAfterReboot              = 'StopConfiguration'\n                RebootNodeIfNeeded             = $false\n                ConfigurationMode              = 'ApplyAndAutoCorrect'\n                CertificateId                  = $DscCertThumbprint\n            }\n        }\n    }\n\n    Write-Output 'Generating MOF file for LCM'\n    $Null = LCMConfig -OutputPath 'C:\\Temp\\LCMConfig'\n\n    Write-Output 'Sets LCM configuration to MOF generated in previous command'\n    Try {\n        Set-DscLocalConfigurationManager -Path 'C:\\Temp\\LCMConfig' -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed to set LCM configuration $_\"\n        Exit 1\n    }\n}\n\nWrite-Output 'Installing NuGet Package Provider'\nTry {\n    $Null = Install-PackageProvider -Name 'NuGet' -MinimumVersion '2.8.5' -Force -ErrorAction Stop\n} Catch [System.Exception] {\n    Write-Output \"Failed to install NuGet Package Provider $_\"\n    Exit 1\n}\n\nWrite-Output 'Setting PSGallery Respository to trusted'\nTry {\n    Set-PSRepository -Name 'PSGallery' -InstallationPolicy 'Trusted' -ErrorAction Stop\n} Catch [System.Exception] {\n    Write-Output \"Failed to set PSGallery Respository to trusted $_\"\n    Exit 1\n}\n\nWrite-Output 'Installing the needed Powershell DSC modules'\nForeach ($Module in $Modules) {\n    Try {\n        Install-Module -Name $Module.Name -RequiredVersion $Module.Version -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed to Import Modules $_\"\n        #Exit 1\n    }\n}\n\nWrite-Output 'Getting certificate AutoEnrollment policy'\nTry {\n    $CertEnrollmentActive = Get-CertificateAutoEnrollmentPolicy -context 'Machine' -Scope 'Local' | Select-Object -ExpandProperty 'PolicyState' -ErrorAction Stop\n} Catch [System.Exception] {\n    Write-Output \"Failed to get certificate AutoEnrollment policy $_\"\n    Exit 1\n}\n\nIf ($CertEnrollmentActive -ne 'Enabled') {\n    Write-Output 'Setting certificate AutoEnrollment policy'\n    Try {\n        Set-CertificateAutoEnrollmentPolicy -ExpirationPercentage 10 -PolicyState 'Enabled' -EnableTemplateCheck -EnableMyStoreManagement -StoreName 'MY' -context 'Machine' -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed to set certificate AutoEnrollment policy $_\"\n        Exit 1\n    }\n}\n\nNew-VolumeFromRawDisk\nInvoke-PreConfig\nInvoke-LcmConfig\n\nIf ('{{DeploymentType}}' -eq 'Management') {\n    Write-Output 'Installing SQL Server Management Studio'\n    (New-Object -TypeName 'System.Net.WebClient').DownloadFile('https://aka.ms/ssmsfullsetup', 'C:\\Temp\\SSMS-Setup.exe')\n    $ArgumentList = '/Quiet'\n    Try {\n        $Process = Start-Process -FilePath 'C:\\Temp\\SSMS-Setup.exe' -ArgumentList $ArgumentList -NoNewWindow -PassThru -Wait -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed to install SQL Server Management Studio $_\"\n        #Exit 1\n    }\n}"
            },
            "CloudWatchOutputConfig": {
              "CloudWatchOutputEnabled": true,
              "CloudWatchLogGroupName": "/aws/SSM-Baseline-${var.ssm_docs_random_string}"
            },
            "InstanceIds": [
              "{{InstanceId.InstanceId}}"
            ],
            "DocumentName": "AWS-RunPowerShellScript"
          },
          "name": "intializeInstance",
          "action": "aws:runCommand",
          "onFailure": "step:signalFailure",
          "nextStep": "configureInstance"
        },
        {
          "inputs": {
            "Parameters": {
              "commands": "Function Get-SecretInfo {\n    [CmdletBinding()]\n    Param (\n        [Parameter(Mandatory = $True)][String]$Domain,\n        [Parameter(Mandatory = $True)][String]$SecretArn\n    )\n\n    Write-Output \"Getting $SecretArn Secret\"\n    Try {\n        $SecretContent = Get-SECSecretValue -SecretId $SecretArn -ErrorAction Stop | Select-Object -ExpandProperty 'SecretString' | ConvertFrom-Json -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed to get $SecretArn Secret $_\"\n        Exit 1\n    }\n\n    Write-Output 'Creating PSCredential object from Secret'\n    $Username = $SecretContent.username\n    $UserPassword = ConvertTo-SecureString ($SecretContent.password) -AsPlainText -Force\n    $DomainCredentials = New-Object -TypeName 'System.Management.Automation.PSCredential' (\"$Domain\\$Username\", $UserPassword)\n    $Credentials = New-Object -TypeName 'System.Management.Automation.PSCredential' ($Username, $UserPassword)\n\n    $Output = [PSCustomObject][Ordered]@{\n        'Credentials'       = $Credentials\n        'DomainCredentials' = $DomainCredentials\n        'Username'          = $Username\n        'UserPassword'      = $UserPassword\n    }\n\n    Return $Output\n}\n\nFunction Get-EniConfig {\n    Write-Output 'Getting network configuration'\n    Try {\n        $NetIpConfig = Get-NetIPConfiguration -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed to get network configuration $_\"\n        Exit 1\n    }\n\n    Write-Output 'Grabbing the current gateway address in order to static IP correctly'\n    $GatewayAddress = $NetIpConfig | Select-Object -ExpandProperty 'IPv4DefaultGateway' | Select-Object -ExpandProperty 'NextHop'\n\n    Write-Output 'Formatting IP address in format needed for IPAdress DSC resource'\n    $IpAddress = $NetIpConfig | Select-Object -ExpandProperty 'IPv4Address' | Select-Object -ExpandProperty 'IpAddress'\n    $Prefix = $NetIpConfig | Select-Object -ExpandProperty 'IPv4Address' | Select-Object -ExpandProperty 'PrefixLength'\n    $InterfaceAlias = $NetIpConfig | Select-Object -ExpandProperty 'InterfaceAlias'\n    $IpAddr = 'IP/CIDR' -replace 'IP', $IpAddress -replace 'CIDR', $Prefix\n\n    Write-Output 'Getting MAC address'\n    Try {\n        $MacAddress = Get-NetAdapter -ErrorAction Stop | Select-Object -ExpandProperty 'MacAddress'\n    } Catch [System.Exception] {\n        Write-Output \"Failed to get MAC address $_\"\n        Exit 1\n    }\n\n    $Output = [PSCustomObject][Ordered]@{\n        'GatewayAddress' = $GatewayAddress\n        'IpAddress'      = $IpAddr\n        'DnsIpAddress'   = $IpAddress\n        'MacAddress'     = $MacAddress\n        'InterfaceAlias' = $InterfaceAlias\n    }\n\n    Return $Output\n}\n\nFunction Set-DscConfiguration {\n    [CmdletBinding()]\n    param(\n        [Parameter(Mandatory = $true)][PSCredential]$DaCredentials,\n        [Parameter(Mandatory = $false)][PSCredential]$EaCredentials,\n        [Parameter(Mandatory = $true)][string]$DeploymentType,\n        [Parameter(Mandatory = $false)][string]$DnsInstanceIP,\n        [Parameter(Mandatory = $true)][string]$DomainDNSName,\n        [Parameter(Mandatory = $true)][string]$DomainNetBIOSName,\n        [Parameter(Mandatory = $false)][string]$DomainType,\n        [Parameter(Mandatory = $true)][string]$GatewayAddress,\n        [Parameter(Mandatory = $false)][string]$InterfaceAlias,\n        [Parameter(Mandatory = $true)][string]$InstanceIP,\n        [Parameter(Mandatory = $true)][string]$InstanceNetBIOSName,\n        [Parameter(Mandatory = $false)][PSCredential]$LaCredentials,\n        [Parameter(Mandatory = $true)][string]$MacAddress,\n        [Parameter(Mandatory = $false)][string]$MadDNSName,\n        [Parameter(Mandatory = $false)][string]$ParentDomainDNSName,\n        [Parameter(Mandatory = $false)][string]$ParentInstanceIP,\n        [Parameter(Mandatory = $false)][PSCredential]$RestoreModeCredentials,\n        [Parameter(Mandatory = $false)][string]$SiteName,\n        [Parameter(Mandatory = $false)][string]$VPCCIDR\n    )\n\n    $VPCDNS = '169.254.169.253'\n\n    If ($DeploymentType -eq 'RootDomainController') {\n        $AClass = 0..8\n        $BClass = 9..16\n        $CClass = 17..24\n        $DClass = 25..32\n        $IP = $VPCCIDR.Split('/')[0]\n        [System.Collections.ArrayList]$IPArray = $IP -Split \"\\.\"\n        $Range = $VPCCIDR.Split('/')[1]\n        If ($AClass -contains $Range) {\n            [System.Array]$Number = $IPArray[0]\n        } Elseif ($BClass -contains $Range) {\n            [System.Array]$Number = $IPArray[0, 1]\n        } Elseif ($CClass -contains $Range) {\n            [System.Array]$Number = $IPArray[0, 1, 2]\n        } Elseif ($DClass -contains $Range) {\n            [System.Array]$Number = $IPArray[0, 1, 2, 3]\n        }\n        [System.Array]::Reverse($Number)\n        $IpRev = $Number -Join \".\"\n        $ZoneName = $IpRev + '.in-addr.arpa'\n    }\n\n    Write-Output 'Getting the DSC encryption thumbprint to secure the MOF file'\n    Try {\n        $DscCertThumbprint = Get-ChildItem -Path 'cert:\\LocalMachine\\My' -ErrorAction Stop | Where-Object { $_.Subject -eq 'CN=DscEncryptCert' } | Select-Object -ExpandProperty 'Thumbprint'\n    } Catch [System.Exception] {\n        Write-Output \"Failed to get DSC cert thumbprint $_\"\n        Exit 1\n    }\n\n    If ($DeploymentType -eq 'RootDomainController' -or $DeploymentType -eq 'ChildDomainController') {\n        Write-Output \"Setting DNS client $_\"\n        Try {\n            Set-DnsClientServerAddress -InterfaceAlias $InterfaceAlias -ServerAddresses ($VPCDNS) -ErrorAction Stop\n        } Catch [System.Exception] {\n            Write-Output \"Failed to set DNS client $_\"\n            Exit 1\n        }\n    }\n\n    Write-Output 'Creating configuration data block that has the certificate information for DSC configuration processing'\n    $ConfigurationData = @{\n        AllNodes = @(\n            @{\n                NodeName                    = '*'\n                #CertificateFile      = 'C:\\Temp\\publickeys\\DscPublicKey.cer'\n                #Thumbprint           = $DscCertThumbprint\n                PSDscAllowDomainUser        = $true\n                PsDscAllowPlainTextPassword = $true\n            },\n            @{\n                NodeName = 'localhost'\n            }\n        )\n    }\n\n    Switch ($DeploymentType) {\n        'RootDomainController' {\n            $Address = @(\n                $DnsInstanceIP,\n                '127.0.0.1',\n                $VPCDNS\n            )\n        }\n        'ChildDomainController' {\n            $Address = @(\n                $ParentInstanceIP,\n                '127.0.0.1',\n                $VPCDNS\n            )\n        }\n        Default {\n            $Address = @(\n                $VPCDNS\n            )\n        }\n    }\n\n    Configuration ConfigInstance {\n        Import-DscResource -ModuleName 'PSDesiredStateConfiguration', 'NetworkingDsc', 'ComputerManagementDsc', 'DnsServerDsc', 'ActiveDirectoryDsc', 'AuditPolicyDsc', 'SChannelDsc'\n        Node LocalHost {\n            NetAdapterName RenameNetAdapterPrimary {\n                NewName    = 'Primary'\n                MacAddress = $MacAddress\n            }\n            PowerPlan SetPlanHighPerformance {\n                IsSingleInstance = 'Yes'\n                Name             = 'High performance'\n            }\n            NetAdapterAdvancedProperty JumboPacket {\n                NetworkAdapterName = 'Primary'\n                RegistryKeyword    = '*JumboPacket'\n                RegistryValue      = 9015\n                DependsOn          = '[NetAdapterName]RenameNetAdapterPrimary'\n            }\n            NetAdapterAdvancedProperty ReceiveBuffers {\n                NetworkAdapterName = 'Primary'\n                RegistryKeyword    = '*ReceiveBuffers'\n                RegistryValue      = 8192\n                DependsOn          = '[NetAdapterName]RenameNetAdapterPrimary'\n            }\n            NetAdapterAdvancedProperty TransmitBuffers {\n                NetworkAdapterName = 'Primary'\n                RegistryKeyword    = '*TransmitBuffers'\n                RegistryValue      = 1024\n                DependsOn          = '[NetAdapterName]RenameNetAdapterPrimary'\n            }\n            NetBios DisableNetBios {\n                InterfaceAlias = 'Primary'\n                Setting        = 'Disable'\n            }\n            NetIPInterface DisableDhcp {\n                Dhcp           = 'Disabled'\n                InterfaceAlias = 'Primary'\n                AddressFamily  = 'IPv4'\n                DependsOn      = '[NetAdapterName]RenameNetAdapterPrimary'\n            }\n            IPAddress SetIP {\n                IPAddress      = $InstanceIP\n                InterfaceAlias = 'Primary'\n                AddressFamily  = 'IPv4'\n                DependsOn      = '[NetIPInterface]DisableDhcp'\n            }\n            DefaultGatewayAddress SetDefaultGateway {\n                Address        = $GatewayAddress\n                InterfaceAlias = 'Primary'\n                AddressFamily  = 'IPv4'\n                DependsOn      = '[IPAddress]SetIP'\n            }\n            DnsServerAddress DnsServerAddress {\n                Address        = $Address\n                InterfaceAlias = 'Primary'\n                AddressFamily  = 'IPv4'\n                DependsOn      = '[DefaultGatewayAddress]SetDefaultGateway'\n            }\n            DnsConnectionSuffix DnsConnectionSuffix {\n                InterfaceAlias                 = 'Primary'\n                ConnectionSpecificSuffix       = $DomainDNSName\n                RegisterThisConnectionsAddress = $True\n                UseSuffixWhenRegistering       = $False\n                DependsOn                      = '[DnsServerAddress]DnsServerAddress'\n            }\n            WindowsFeature DnsTools {\n                Ensure    = 'Present'\n                Name      = 'RSAT-DNS-Server'\n                DependsOn = '[DnsConnectionSuffix]DnsConnectionSuffix'\n            }\n            WindowsFeature RSAT-AD-Tools {\n                Ensure    = 'Present'\n                Name      = 'RSAT-AD-Tools'\n                DependsOn = '[WindowsFeature]DnsTools'\n            }\n            WindowsFeature RSAT-ADDS {\n                Ensure    = 'Present'\n                Name      = 'RSAT-ADDS'\n                DependsOn = '[WindowsFeature]RSAT-AD-Tools'\n            }\n            WindowsFeature GPMC {\n                Ensure    = 'Present'\n                Name      = 'GPMC'\n                DependsOn = '[WindowsFeature]RSAT-ADDS'\n            }\n            If ($DeploymentType -eq 'RootDomainController' -or $DeploymentType -eq 'ChildDomainController' -or $DeploymentType -eq 'AdditionalDomainController') {\n                WindowsFeature DNS {\n                    Ensure    = 'Present'\n                    Name      = 'DNS'\n                    DependsOn = '[WindowsFeature]GPMC'\n                }\n                WindowsFeature AD-Domain-Services {\n                    Ensure    = 'Present'\n                    Name      = 'AD-Domain-Services'\n                    DependsOn = '[WindowsFeature]DNS'\n                }\n                Service ActiveDirectoryWebServices {\n                    Name        = 'ADWS'\n                    StartupType = 'Automatic'\n                    State       = 'Running'\n                    DependsOn   = '[WindowsFeature]AD-Domain-Services'\n                }\n                Computer Rename {\n                    Name      = $InstanceNetBIOSName\n                    DependsOn = '[WindowsFeature]AD-Domain-Services'\n                }\n                User AdministratorPassword {\n                    UserName  = 'Administrator'\n                    Password  = $LaCredentials\n                    DependsOn = '[Computer]Rename'\n                }\n                Switch ($DeploymentType) {\n                    'RootDomainController' {\n                        ADDomain PrimaryDC {\n                            DomainName                    = $DomainDnsName\n                            DomainNetBIOSName             = $DomainNetBIOSName\n                            Credential                    = $DaCredentials\n                            SafemodeAdministratorPassword = $RestoreModeCredentials\n                            DatabasePath                  = 'D:\\NTDS'\n                            LogPath                       = 'D:\\NTDS'\n                            SysvolPath                    = 'D:\\SYSVOL'\n                            DependsOn                     = '[User]AdministratorPassword'\n                        }\n                    }    \n                    'ChildDomainController' {\n                        ADDomain PrimaryDC {\n                            DomainName                    = $DomainNetBIOSName.ToLower()\n                            DomainNetBIOSName             = $DomainNetBIOSName\n                            ParentDomainName              = $ParentDomainDNSName\n                            Credential                    = $EaCredentials\n                            SafemodeAdministratorPassword = $RestoreModeCredentials\n                            DatabasePath                  = 'D:\\NTDS'\n                            LogPath                       = 'D:\\NTDS'\n                            SysvolPath                    = 'D:\\SYSVOL'\n                            DependsOn                     = '[User]AdministratorPassword'\n                        }\n                    }\n                    'AdditionalDomainController' {\n                        ADDomainController PrimaryDC {\n                            DomainName                    = $DomainDnsName\n                            Credential                    = $DaCredentials\n                            SafemodeAdministratorPassword = $RestoreModeCredentials\n                            DatabasePath                  = 'D:\\NTDS'\n                            LogPath                       = 'D:\\NTDS'\n                            SysvolPath                    = 'D:\\SYSVOL'\n                            DependsOn                     = '[User]AdministratorPassword'\n                        }\n                    }\n                }\n                If ($DeploymentType -eq 'AdditionalDomainController') {\n                    WaitForADDomain WaitForPrimaryDC {\n                        DomainName  = $DomainDnsName\n                        WaitTimeout = 600\n                        DependsOn   = '[ADDomainController]PrimaryDC'\n                    }\n                } Else {\n                    WaitForADDomain WaitForPrimaryDC {\n                        DomainName  = $DomainDnsName\n                        WaitTimeout = 600\n                        DependsOn   = '[ADDomain]PrimaryDC'\n                    }\n                }\n                ADGroup AddAdminToDomainAdminsGroup {\n                    Ensure           = 'Present'\n                    GroupName        = 'Domain Admins'\n                    GroupScope       = 'Global'\n                    Category         = 'Security'\n                    MembersToInclude = @('Administrator')\n                    Credential       = $DaCredentials\n                    DependsOn        = '[WaitForADDomain]WaitForPrimaryDC'\n                }\n                If ($DeploymentType -eq 'RootDomainController') {\n                    ADForestProperties TSL {\n                        ForestName        = $DomainDnsName\n                        TombStoneLifetime = 60\n                        DependsOn         = '[WaitForADDomain]WaitForPrimaryDC'\n                    }\n                    ADReplicationSite RegionSite {\n                        Name                       = $SiteName\n                        RenameDefaultFirstSiteName = $true\n                        DependsOn                  = '[WaitForADDomain]WaitForPrimaryDC', '[Service]ActiveDirectoryWebServices'\n                    }\n                    ADReplicationSubnet VPCCIDR {\n                        Name      = $VPCCIDR\n                        Site      = $SiteName\n                        DependsOn = '[ADReplicationSite]RegionSite'\n                    }                    \n                    ADGroup AddAdminToEnterpriseAdminsGroup {\n                        Ensure           = 'Present'\n                        GroupName        = 'Enterprise Admins'\n                        GroupScope       = 'Universal'\n                        Category         = 'Security'\n                        MembersToInclude = @('Administrator')\n                        Credential       = $DaCredentials\n                        DependsOn        = '[WaitForADDomain]WaitForPrimaryDC'\n                    }\n                    ADGroup AddAdminToSchemaAdminsGroup {\n                        Ensure           = 'Present'\n                        GroupName        = 'Schema Admins'\n                        GroupScope       = 'Universal'\n                        Category         = 'Security'\n                        MembersToExclude = @('Administrator')\n                        Credential       = $DaCredentials\n                        DependsOn        = '[WaitForADDomain]WaitForPrimaryDC'\n                    }\n                    ADOptionalFeature RecycleBin {\n                        FeatureName                       = 'Recycle Bin Feature'\n                        EnterpriseAdministratorCredential = $DaCredentials\n                        ForestFQDN                        = $DomainDnsName\n                        DependsOn                         = '[WaitForADDomain]WaitForPrimaryDC'\n                    }\n                    DnsServerADZone CreateReverseLookupZone {\n                        Ensure           = 'Present'\n                        Name             = $ZoneName\n                        DynamicUpdate    = 'Secure'\n                        ReplicationScope = 'Forest'\n                        DependsOn        = '[WaitForADDomain]WaitForPrimaryDC'\n                    }\n                    DnsServerZoneAging DnsServerZoneAging-FL {\n                        Name              = $DomainDnsName\n                        Enabled           = $true\n                        RefreshInterval   = 168\n                        NoRefreshInterval = 168\n                        DependsOn         = '[WaitForADDomain]WaitForPrimaryDC'\n                    }\n                    DnsServerZoneAging DnsServerZoneAging-RL {\n                        Name              = $ZoneName\n                        Enabled           = $true\n                        RefreshInterval   = 168\n                        NoRefreshInterval = 168\n                        DependsOn         = '[DnsServerADZone]CreateReverseLookupZone'\n                    }                                     \n                }\n                DnsServerForwarder ForwardtoVPCDNS {\n                    IsSingleInstance = 'Yes'\n                    IPAddresses      = $VPCDNS\n                    DependsOn        = '[WaitForADDomain]WaitForPrimaryDC'\n                }\n                If ($DeploymentType -eq 'RootDomainController' -or $DeploymentType -eq 'ChildDomainController') {\n                    ADKDSKey KdsKey {\n                        Ensure                   = 'Present'\n                        EffectiveTime            = ((Get-Date).addhours(-10))\n                        AllowUnsafeEffectiveTime = $True\n                        DependsOn                = '[WaitForADDomain]WaitForPrimaryDC'\n                    }\n                }\n                ADServicePrincipalName WSMAN-FQDN {\n                    ServicePrincipalName = \"WSMAN/$InstanceNetBIOSName.$DomainDnsName\"\n                    Account              = \"$InstanceNetBIOSName$\"\n                    DependsOn            = '[WaitForADDomain]WaitForPrimaryDC'\n                }\n                ADServicePrincipalName WSMAN-SN {\n                    ServicePrincipalName = \"WSMAN/$InstanceNetBIOSName\"\n                    Account              = \"$InstanceNetBIOSName$\"\n                    DependsOn            = '[WaitForADDomain]WaitForPrimaryDC'\n                }\n                DnsServerScavenging SetServerScavenging {\n                    DnsServer          = 'localhost'\n                    ScavengingState    = $true\n                    ScavengingInterval = '7.00:00:00'\n                    RefreshInterval    = '7.00:00:00'\n                    NoRefreshInterval  = '7.00:00:00'\n                    DependsOn          = '[WaitForADDomain]WaitForPrimaryDC'\n                }\n                DnsServerDiagnostics Diagnostics {\n                    DnsServer                            = 'localhost'\n                    Answers                              = $true\n                    EnableLogFileRollover                = $true\n                    EnableLoggingForLocalLookupEvent     = $true\n                    EnableLoggingForPluginDllEvent       = $true\n                    EnableLoggingForRecursiveLookupEvent = $true\n                    EnableLoggingForRemoteServerEvent    = $true\n                    EnableLoggingForServerStartStopEvent = $true\n                    EnableLoggingForTombstoneEvent       = $true\n                    EnableLoggingForZoneDataWriteEvent   = $true\n                    EnableLoggingForZoneLoadingEvent     = $true\n                    EnableLoggingToFile                  = $true\n                    EventLogLevel                        = 7\n                    FullPackets                          = $true\n                    LogFilePath                          = 'C:\\DnsLogs\\dns.log'\n                    MaxMBFileSize                        = 500000000\n                    Notifications                        = $true\n                    Queries                              = $true\n                    QuestionTransactions                 = $true\n                    ReceivePackets                       = $true\n                    SaveLogsToPersistentStorage          = $true\n                    SendPackets                          = $true\n                    TcpPackets                           = $true\n                    UdpPackets                           = $true\n                    UnmatchedResponse                    = $true\n                    Update                               = $true\n                    UseSystemEventLog                    = $true\n                    WriteThrough                         = $true\n                }\n            } Else {\n                Computer JoinDomain {\n                    Name       = $InstanceNetBIOSName\n                    DomainName = $DomainDnsName\n                    Credential = $DaCredentials\n                    DependsOn  = '[WindowsFeature]GPMC'\n                }\n            }\n        }\n    }\n    Write-Output 'Generating MOF file'\n    $Null = ConfigInstance -OutputPath 'C:\\Temp\\ConfigInstance' -ConfigurationData $ConfigurationData\n}\n\nFunction Invoke-DscStatusCheck {\n    $LCMState = Get-DscLocalConfigurationManager -ErrorAction SilentlyContinue | Select-Object -ExpandProperty 'LCMState'\n    If ($LCMState -eq 'PendingConfiguration' -Or $LCMState -eq 'PendingReboot') {\n        Exit 3010\n    } Else {\n        Write-Output 'DSC Config Completed'\n    }\n}\n\n$Secret = Get-SecretInfo -Domain '{{DomainNetBIOSName}}' -SecretArn '{{AdministratorSecretName}}'\n$EniConfig = Get-EniConfig\n$DeploymentType = '{{DeploymentType}}'\n\nSwitch ($DeploymentType) {\n    'RootDomainController' {\n        Set-DscConfiguration -DaCredentials $Secret.DomainCredentials -DeploymentType 'RootDomainController' -DnsInstanceIP $EniConfig.DnsIpAddress -DomainDNSName '{{DomainDNSName}}' -DomainNetBIOSName '{{DomainNetBIOSName}}' -GatewayAddress $EniConfig.GatewayAddress -InterfaceAlias $EniConfig.InterfaceAlias -InstanceIP $EniConfig.IpAddress -InstanceNetBIOSName '{{ServerNetBIOSName}}' -LaCredentials $Secret.Credentials -MacAddress $EniConfig.MacAddress -MadDNSName '{{MadDNSName}}'-RestoreModeCredentials $Secret.Credentials -SiteName '{{global:REGION}}' -VPCCIDR '{{VPCCIDR}}'\n    }\n    'ChildDomainController' {\n        $EaSecret = Get-SecretInfo -Domain '{{ParentDomainDNSName}}' -SecretArn '{{AdministratorSecretName}}'\n        Set-DscConfiguration -DaCredentials $Secret.DomainCredentials -DeploymentType 'ChildDomainController' -DomainDNSName '{{DomainDNSName}}' -DomainNetBIOSName '{{DomainNetBIOSName}}' -EaCredentials $EaSecret.DomainCredentials -GatewayAddress $EniConfig.GatewayAddress -InterfaceAlias $EniConfig.InterfaceAlias -InstanceIP $EniConfig.IpAddress -InstanceNetBIOSName '{{ServerNetBIOSName}}' -LaCredentials $Secret.Credentials -MacAddress $EniConfig.MacAddress -ParentDomainDNSName '{{ParentDomainDNSName}}' -ParentInstanceIP '{{ParentInstanceIP}}' -RestoreModeCredentials $Secret.Credentials -VPCCIDR '{{VPCCIDR}}'\n    }\n    'AdditionalDomainController' {\n        Set-DscConfiguration -DaCredentials $Secret.DomainCredentials -DeploymentType 'AdditionalDomainController' -DomainDNSName '{{DomainDNSName}}' -DomainNetBIOSName '{{DomainNetBIOSName}}' -GatewayAddress $EniConfig.GatewayAddress -InterfaceAlias $EniConfig.InterfaceAlias -InstanceIP $EniConfig.IpAddress -InstanceNetBIOSName '{{ServerNetBIOSName}}' -LaCredentials $Secret.Credentials -MacAddress $EniConfig.MacAddress -ParentInstanceIP '{{ParentInstanceIP}}' -RestoreModeCredentials $Secret.Credentials -VPCCIDR '{{VPCCIDR}}'\n    } \n    default {\n        Set-DscConfiguration -DaCredentials $Secret.DomainCredentials -DeploymentType 'Member' -DomainDNSName '{{DomainDNSName}}' -DomainNetBIOSName '{{DomainNetBIOSName}}' -GatewayAddress $EniConfig.GatewayAddress -InstanceIP $EniConfig.IpAddress -InstanceNetBIOSName '{{ServerNetBIOSName}}' -MacAddress $EniConfig.MacAddress\n    }\n}\n\nStart-DscConfiguration 'C:\\Temp\\ConfigInstance' -Wait -Verbose -Force\nInvoke-DscStatusCheck\n\nIf ($DeploymentType -eq 'RootDomainController') {\n    Function Get-SecretInfo {\n        [CmdletBinding()]\n        Param (\n            [Parameter(Mandatory = $True)][String]$Domain,\n            [Parameter(Mandatory = $True)][String]$SecretArn\n        )\n\n        Write-Output \"Getting $SecretArn Secret\"\n        Try {\n            $SecretContent = Get-SECSecretValue -SecretId $SecretArn -ErrorAction Stop | Select-Object -ExpandProperty 'SecretString' | ConvertFrom-Json -ErrorAction Stop\n        } Catch [System.Exception] {\n            Write-Output \"Failed to get $SecretArn Secret $_\"\n            Exit 1\n        }\n\n        Write-Output 'Creating PSCredential object from Secret'\n        $Username = $SecretContent.username\n        $UserPassword = ConvertTo-SecureString ($SecretContent.password) -AsPlainText -Force\n        $DomainCredentials = New-Object -TypeName 'System.Management.Automation.PSCredential' (\"$Domain\\$Username\", $UserPassword)\n        $Credentials = New-Object -TypeName 'System.Management.Automation.PSCredential' ($Username, $UserPassword)\n\n        $Output = [PSCustomObject][Ordered]@{\n            'Credentials'       = $Credentials\n            'DomainCredentials' = $DomainCredentials\n            'Username'          = $Username\n            'UserPassword'      = $UserPassword\n        }\n\n        Return $Output\n    }\n\n    Function Invoke-TrustAction {\n        [CmdletBinding()]\n        Param(\n            [parameter(Mandatory = $true)][String]$RemoteFQDN,\n            [parameter(Mandatory = $true)][String]$TrustDirection,\n            [parameter(Mandatory = $true)][String]$TrustPassword\n        )\n\n        $LocalForest = [System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest() \n        $AdTrustDir = [System.DirectoryServices.ActiveDirectory.TrustDirection]::$TrustDirection\n        $Null = Clear-DnsServerCache -Force -ErrorAction SilentlyContinue\n        $Null = Clear-DnsClientCache -ErrorAction SilentlyContinue\n        $LocalForest.CreateLocalSideOfTrustRelationship($RemoteFQDN, $AdTrustDir, $TrustPassword)\n        $LocalForest.VerifyOutboundTrustRelationship($RemoteFQDN)\n        & ksetup.exe /SetEncTypeAttr $RemoteFQDN 'RC4-HMAC-MD5' 'AES128-CTS-HMAC-SHA1-96' 'AES256-CTS-HMAC-SHA1-96'\n    }\n\n    Function Add-FSxOuAcl {\n        [CmdletBinding()]\n        param(\n            [Parameter(Mandatory = $true)][string]$AclPath,\n            [Parameter(Mandatory = $true)][Security.Principal.SecurityIdentifier]$IdentityReference,\n            [Parameter(Mandatory = $true)][System.DirectoryServices.ActiveDirectoryRights]$ActiveDirectoryRights,\n            [Parameter(Mandatory = $true)][System.Security.AccessControl.AccessControlType]$AccessControlType,\n            [Parameter(Mandatory = $false)][Guid]$ObjectGuid,\n            [Parameter(Mandatory = $false)][System.DirectoryServices.ActiveDirectorySecurityInheritance]$ActiveDirectorySecurityInheritance,\n            [Parameter(Mandatory = $false)][Guid]$InheritedObjectGuid\n        )\n\n        Import-Module -Name 'ActiveDirectory' -Force\n\n        [Security.Principal.SecurityIdentifier]$IdentityReference = $IdentityReference | Select-Object -ExpandProperty 'Value'\n\n        $ArgumentList = $IdentityReference, $ActiveDirectoryRights, $AccessControlType, $ObjectGuid, $ActiveDirectorySecurityInheritance, $InheritedObjectGuid\n        $ArgumentList = $ArgumentList.Where({ $_ -ne $Null })\n\n        Write-Output 'Creating ACL object'\n        Try {\n            $Rule = New-Object -TypeName 'System.DirectoryServices.ActiveDirectoryAccessRule' -ArgumentList $ArgumentList -ErrorAction Stop\n        } Catch [System.Exception] {\n            Write-Output \"Failed to create ACL object $_\"\n            Exit 1\n        }\n\n        Write-Output \"Getting ACL for $AclPath\"\n        Try {\n            $ObjectAcl = Get-Acl -Path \"AD:\\$AclPath\" -ErrorAction Stop\n        } Catch [System.Exception] {\n            Write-Output \"Failed to get ACL for $AclPath $_\"\n            Exit 1\n        }\n\n        $ObjectAcl.AddAccessRule($Rule) \n\n        Write-Output \"Setting ACL for $AclPath\"\n        Try {\n            Set-Acl -AclObject $ObjectAcl -Path \"AD:\\$AclPath\" -ErrorAction Stop\n        } Catch [System.Exception] {\n            Write-Output \"Failed to set ACL for $AclPath $_\"\n            Exit 1\n        }\n    }\n\n    If ('{{IntegrateFsxOnprem}}' -eq 'True') {\n        Write-Output 'Getting domain information'\n        Try {\n            $Domain = Get-ADDomain -ErrorAction Stop\n        } Catch [System.Exception] {\n            Write-Output \"Failed to get domain information $_\"\n            Exit 1\n        }\n\n        $FQDN = $Domain | Select-Object -ExpandProperty 'DNSRoot'\n\n        $FsxOU = \"OU=FSx,{{FsxOnpremParentOu}}\"\n\n        Write-Output 'Creating OU FSx'\n        Try {\n            New-ADOrganizationalUnit -Name 'FSx' -Path '{{FsxOnpremParentOu}}' -ProtectedFromAccidentalDeletion $True -ErrorAction Stop\n        } Catch [System.Exception] {\n            Write-Output \"Failed to create OU FSx $_\"\n            Exit 1\n        }\n\n        $UserPassword = (Get-SecretInfo -Domain '{{DomainNetBIOSName}}' -SecretArn '{{FsxOnpremSvcSecret}}').UserPassword\n\n        $User = @{\n            AccountPassword        = $UserPassword\n            Name                   = '{{FsxOnpremSvcUn}}'\n            DisplayName            = '{{FsxOnpremSvcUn}}'\n            SamAccountName         = '{{FsxOnpremSvcUn}}'\n            UserPrincipalName      = \"{{FsxOnpremSvcUn}}@$FQDN\"\n            KerberosEncryptionType = 'AES128', 'AES256'\n            PasswordNeverExpires   = $True\n            Enabled                = $True\n            Path                   = $FsxOU \n        }\n\n        Write-Output 'Creating {{FsxOnpremSvcUn}}'\n        Try {\n            New-ADUser @User\n        } Catch [System.Exception] {\n            Write-Output \"Failed to create {{FsxOnpremSvcUn}} $_\"\n            Exit 1\n        }\n\n        Write-Output 'Creating FSx Admins Group'\n        Try {\n            New-ADGroup -DisplayName '{{FsxOnpremAdmins}}' -GroupCategory 'Security' -GroupScope 'DomainLocal' -Name '{{FsxOnpremAdmins}}' -Path $FsxOU -SamAccountName '{{FsxOnpremAdmins}}'\n        } Catch [System.Exception] {\n            Write-Output \"Failed to create {{FsxOnpremAdmins}} $_\"\n            Exit 1\n        }\n\n        Write-Output 'Getting RootDSE information'\n        Try {\n            $RootDse = Get-ADRootDSE -ErrorAction Stop\n        } Catch [System.Exception] {\n            Write-Output \"Failed to get RootDSE information $_\"\n            Exit 1\n        }\n\n        Write-Output 'Getting computer SchemaNamingContext'\n        Try {\n            [System.GUID]$ComputerNameGuid = (Get-ADObject -SearchBase $RootDse.SchemaNamingContext -Filter { lDAPDisplayName -eq 'computer' } -Properties 'schemaIDGUID' -ErrorAction Stop).schemaIDGUID\n        } Catch [System.Exception] {\n            Write-Output \"Failed to get computer SchemaNamingContext $_\"\n            Exit 1\n        }\n\n        $ExtendedRightsMap = @{ }\n\n        Write-Output 'Getting ExtendedRightsMap'\n        Try {\n            $ErNamingContexts = Get-ADObject -SearchBase $RootDse.ConfigurationNamingContext -LDAPFilter '(&(objectclass=controlAccessRight)(rightsguid=*))' -Properties displayName, rightsGuid -ErrorAction Stop\n        } Catch [System.Exception] {\n            Write-Output \"Failed to get ExtendedRightsMap $_\"\n            Exit 1\n        }\n\n        ForEach ($ErNamingContext in $ErNamingContexts) {\n            $ExtendedRightsMap[$ErNamingContext.displayName] = [System.GUID]$ErNamingContext.rightsGuid\n        }\n\n        $NullGuid = [guid]'00000000-0000-0000-0000-000000000000'\n\n        $AclRules = @(\n            @{\n                ActiveDirectoryRights              = 'CreateChild, DeleteChild'\n                AccessControlType                  = 'Allow'\n                ObjectGUID                         = $ComputerNameGuid\n                ActiveDirectorySecurityInheritance = 'All'\n                InheritedObjectGuid                = $NullGuid\n            },\n            @{\n                ActiveDirectoryRights              = 'ExtendedRight'\n                AccessControlType                  = 'Allow'\n                ObjectGUID                         = $ExtendedRightsMap['Validated write to service principal name']\n                ActiveDirectorySecurityInheritance = 'Descendents'\n                InheritedObjectGuid                = $ComputerNameGuid\n            },\n            @{\n                ActiveDirectoryRights              = 'ExtendedRight'\n                AccessControlType                  = 'Allow'\n                ObjectGUID                         = $ExtendedRightsMap['Account Restrictions']\n                ActiveDirectorySecurityInheritance = 'Descendents'\n                InheritedObjectGuid                = $ComputerNameGuid\n            },\n            @{\n                ActiveDirectoryRights              = 'ExtendedRight'\n                AccessControlType                  = 'Allow'\n                ObjectGUID                         = $ExtendedRightsMap['Reset Password']\n                ActiveDirectorySecurityInheritance = 'Descendents'\n                InheritedObjectGuid                = $ComputerNameGuid\n            },\n            @{\n                ActiveDirectoryRights              = 'ExtendedRight'\n                AccessControlType                  = 'Allow'\n                ObjectGUID                         = $ExtendedRightsMap['Validated write to DNS host name']\n                ActiveDirectorySecurityInheritance = 'Descendents'\n                InheritedObjectGuid                = $ComputerNameGuid\n            }\n        )\n\n        Write-Output 'Getting {{FsxOnpremSvcUn}} SID'\n        Try {\n            $IdentityReference = Get-ADUser -Identity '{{FsxOnpremSvcUn}}' -ErrorAction Stop | Select-Object -ExpandProperty 'SID'\n        } Catch [System.Exception] {\n            Write-Output \"Failed to get {{FsxOnpremSvcUn}} SID $_\"\n            Exit 1\n        }\n\n        Foreach ($AclRule in $AclRules) {\n            Add-FSxOuAcl -AclPath $FsxOU -IdentityReference $IdentityReference -ActiveDirectoryRights $AclRule.ActiveDirectoryRights -AccessControlType $AclRule.AccessControlType -ObjectGUID $AclRule.ObjectGUID -ActiveDirectorySecurityInheritance $AclRule.ActiveDirectorySecurityInheritance -InheritedObjectGuid $AclRule.InheritedObjectGuid\n        }\n    }\n    \n    $TrustDirection = '{{TrustDirection}}'\n    If ($TrustDirection -ne 'None') {\n        $VPCDNS = '169.254.169.253'\n        Try {\n            Add-DnsServerConditionalForwarderZone -Name {{MadDNSName}} -ReplicationScope \"Forest\" -MasterServers $VPCDNS\n        } Catch [System.Exception] {\n            Write-Output \"Failed to create conditional fowarder MAD domain. $_\"\n            Exit 1\n        }\n\n        Switch ($TrustDirection) {\n            'Two-Way' { $TrustDirOnprem = 'Bidirectional' }\n            'One-Way: Outgoing' { $TrustDirOnprem = 'Inbound' }\n            'One-Way: Incoming' { $TrustDirOnprem = 'Outbound' }\n            Default { Throw 'InvalidArgument: Invalid value is passed for parameter TrustDirection' }\n        }\n\n        $TrustPassword = (Get-SecretInfo -Domain '{{DomainNetBIOSName}}' -SecretArn '{{TrustSecretName}}').UserPassword\n\n        Write-Output 'Creating Onprem side of trust.'\n        Invoke-TrustAction -RemoteFQDN '{{MadDNSName}}' -TrustPassword $TrustPassword $TrustDirOnprem\n    }\n}\n\n$TrustDirection = '{{TrustDirection}}'\nIf ($DeploymentType -eq 'EnterpriseCAManagementInstance' -or $DeploymentType -eq 'ManagementInstance' -and $TrustDirection -ne 'None') {\n    $IP = '{{VPCCIDR}}'.Split('/')[0]\n\n    [System.Collections.ArrayList]$IPArray = $IP -Split \"\\.\"\n\n    $VPCDNS = $IPArray[0, 1, 2] + 2 -Join \".\"\n\n    Switch ($TrustDirection) {\n        'Two-Way' {\n            $TrustDirMAD = 'Two-Way'\n        }\n        'One-Way: Outgoing' {\n            $TrustDirMAD = 'One-Way: Outgoing'\n        }\n        'One-Way: Incoming' {\n            $TrustDirMAD = 'One-Way: Incoming'\n        }\n        Default { Throw 'InvalidArgument: Invalid value is passed for parameter TrustDirection' }\n    }\n\n    $TrustTypeForest = New-Object -TypeName 'Amazon.DirectoryService.TrustType' -ArgumentList 'Forest'\n    $TrustDir = New-Object -TypeName 'Amazon.DirectoryService.TrustDirection' -ArgumentList $TrustDirMAD\n    $SelectiveAuthDis = New-Object -TypeName 'Amazon.DirectoryService.SelectiveAuth' -ArgumentList 'Disabled'\n    $TrustPassword = (Get-SecretInfo -Domain '{{DomainNetBIOSName}}' -SecretArn '{{AdministratorSecretName}}').UserPassword\n\n    Write-Output 'Creating trust between MAD and Onprem.'\n    Try {\n        $Trust = New-DSTrust -DirectoryId '{{MadDirectoryID}}' -ConditionalForwarderIpAddr $VPCDNS -RemoteDomainName '{{OnpremDomainDNSName}}' -SelectiveAuth $SelectiveAuthDis -TrustDirection $TrustDir -TrustType $TrustTypeForest -TrustPassword $TrustPassword\n    } Catch [System.Exception] {\n        Write-Output \"Failed to create trust between MAD and Onprem. $_\"\n        Exit 1\n    }\n\n    $Counter = 0\n    Do {\n        Try {\n            $Truststate = Get-DSTrust -DirectoryId '{{MadDirectoryID}}' -TrustId $Trust -ErrorAction SilentlyContinue | Select-Object -ExpandProperty 'TrustState' | Select-Object -ExpandProperty 'Value'\n        } Catch [System.Exception] {\n            Write-Output \"Failed to get trust state $_\"\n            $Truststate = $Null\n        }\n        If ($Truststate -ne 'Verified' -or $Truststate -eq 'Failed') {\n            $Counter ++\n            Write-Output 'Trust not Verified, sleeping 10 seconds and will try again.'\n            Start-Sleep -Seconds 10\n        }\n    } Until ($Truststate -eq 'Verified' -or $Truststate -eq 'Failed' -or $Counter -eq 30)\n\n    If ($Truststate -eq 'Failed' -or $Counter -eq 30) {\n        Write-Output 'Trust failed to create or never went Verified in 5 minutes'\n        Exit 1\n    }\n}"
            },
            "CloudWatchOutputConfig": {
              "CloudWatchOutputEnabled": true,
              "CloudWatchLogGroupName": "/aws/SSM-Baseline-${var.ssm_docs_random_string}"
            },
            "InstanceIds": [
              "{{InstanceId.InstanceId}}"
            ],
            "DocumentName": "AWS-RunPowerShellScript"
          },
          "name": "configureInstance",
          "action": "aws:runCommand",
          "onFailure": "step:signalFailure",
          "nextStep": "DeployPKI"
        },
        {
          "inputs": {
            "Choices": [
              {
                "StringEquals": "Yes",
                "Variable": "{{DeployPki}}",
                "NextStep": "runPkiSsmAuto"
              },
              {
                "StringEquals": "No",
                "Variable": "{{DeployPki}}",
                "NextStep": "runAuditPolSsmAuto"
              }
            ]
          },
          "name": "DeployPKI",
          "action": "aws:branch"
        },
        {
          "inputs": {
            "RuntimeParameters": {
              "ServerNetBIOSName": [
                "{{ServerNetBIOSName}}"
              ],
              "DomainType": [
                "{{DomainType}}"
              ],
              "DomainNetBIOSName": [
                "{{DomainNetBIOSName}}"
              ],
              "VPCCIDR": [
                "{{VPCCIDR}}"
              ],
              "AdministratorSecretName": [
                "{{AdministratorSecretName}}"
              ],
              "DeploymentType": [
                "{{DeploymentType}}"
              ],
              "StackName": [
                "{{StackName}}"
              ]
            },
            "DocumentName": "SSM-Pki-${var.ssm_docs_random_string}"
          },
          "name": "runPkiSsmAuto",
          "action": "aws:executeAutomation",
          "onFailure": "step:signalFailure",
          "nextStep": "runAuditPolSsmAuto"
        },
        {
          "inputs": {
            "RuntimeParameters": {
              "ServerNetBIOSName": [
                "{{ServerNetBIOSName}}"
              ],
              "ServerRole": [
                "{{ServerRole}}"
              ],
              "VPCCIDR": [
                "{{VPCCIDR}}"
              ],
              "StackName": [
                "{{StackName}}"
              ]
            },
            "DocumentName": "SSM-AuditPol-${var.ssm_docs_random_string}"
          },
          "name": "runAuditPolSsmAuto",
          "action": "aws:executeAutomation",
          "onFailure": "step:signalFailure"
        },
        {
          "inputs": {
            "Choices": [
              {
                "Not": {
                  "StringEquals": "",
                  "Variable": "{{StackName}}"
                },
                "NextStep": "signalSuccess"
              },
              {
                "StringEquals": "",
                "Variable": "{{StackName}}",
                "NextStep": "sleepEnd"
              }
            ]
          },
          "name": "cfnSignalEnd",
          "action": "aws:branch"
        },
        {
          "inputs": {
            "Status": "SUCCESS",
            "UniqueId": "{{InstanceId.InstanceId}}",
            "LogicalResourceId": "{{LogicalResourceId}}",
            "Service": "cloudformation",
            "Api": "SignalResource",
            "StackName": "{{StackName}}"
          },
          "name": "signalSuccess",
          "action": "aws:executeAwsApi",
          "isEnd": true
        },
        {
          "inputs": {
            "Duration": "PT1S"
          },
          "name": "sleepEnd",
          "action": "aws:sleep",
          "isEnd": true
        },
        {
          "inputs": {
            "Status": "FAILURE",
            "UniqueId": "{{InstanceId.InstanceId}}",
            "LogicalResourceId": "{{LogicalResourceId}}",
            "Service": "cloudformation",
            "Api": "SignalResource",
            "StackName": "{{StackName}}"
          },
          "name": "signalFailure",
          "action": "aws:executeAwsApi"
        }
      ]
    }
DOC
}

resource "aws_ssm_document" "ssm_auditpol" {
  name            = "SSM-AuditPol-${var.ssm_docs_random_string}"
  document_format = "JSON"
  document_type   = "Automation"
  content         = <<DOC
    {
      "schemaVersion": "0.3",
      "description": "Configure Kinesis Agent for Windows, Windows Auditing Policy, and deployment cleanup using SSM Automation",
      "parameters": {
        "ServerNetBIOSName": {
          "description": "NetBIOS name of the first Active Directory Domain Controller (up to 15 characters)",
          "type": "String"
        },
        "ServerRole": {
          "description": "Role server will be (DomainController or CertificateAuthority)",
          "type": "String"
        },
        "VPCCIDR": {
          "description": "CIDR Block for the VPC",
          "type": "String"
        },
        "StackName": {
          "description": "Stack Name Input for cfn resource signal",
          "type": "String"
        }
      },
      "mainSteps": [
        {
          "outputs": [
            {
              "Type": "String",
              "Name": "InstanceId",
              "Selector": "$.Reservations[0].Instances[0].InstanceId"
            }
          ],
          "inputs": {
            "Filters": [
              {
                "Values": [
                  "{{ServerNetBIOSName}}"
                ],
                "Name": "tag:Name"
              },
              {
                "Values": [
                  "{{StackName}}"
                ],
                "Name": "tag:aws:cloudformation:stack-name"
              },
              {
                "Values": [
                  "running"
                ],
                "Name": "instance-state-name"
              }
            ],
            "Service": "ec2",
            "Api": "DescribeInstances"
          },
          "name": "InstanceId",
          "action": "aws:executeAwsApi",
          "nextStep": "configureInstance"
        },
        {
          "inputs": {
            "Parameters": {
              "commands": "Function Invoke-Cleanup {\n    [CmdletBinding()]\n    Param (\n        [Parameter(Mandatory = $true)][String]$VPCCIDR\n    )\n\n    Write-Output 'Setting Windows Firewall WinRM Public rule to allow VPC CIDR traffic'\n    Try {\n        Set-NetFirewallRule -Name 'WINRM-HTTP-In-TCP-PUBLIC' -RemoteAddress $VPCCIDR\n    } Catch [System.Exception] {\n        Write-Output \"Failed allow WinRM Traffic from VPC CIDR $_\"\n    }\n\n    Write-Output 'Removing DSC Configuration'\n    Try {\n        Remove-DscConfigurationDocument -Stage 'Current' -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed build DSC Configuration $_\"\n    }\n\n    Write-Output 'Re-enabling Windows Firewall'\n    Try {\n        Get-NetFirewallProfile -ErrorAction Stop | Set-NetFirewallProfile -Enabled 'True' -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed re-enable firewall $_\"\n    }\n\n    Write-Output 'Removing build files'\n    Try {\n        Remove-Item -Path 'C:\\Temp' -Recurse -Force -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed remove build files $_\"\n    }\n\n    Write-Output 'Removing self signed cert'\n    Try {\n        $SelfSignedThumb = Get-ChildItem -Path 'cert:\\LocalMachine\\My\\' -ErrorAction Stop | Where-Object { $_.Subject -eq 'CN=DscEncryptCert' } | Select-Object -ExpandProperty 'Thumbprint'\n        Remove-Item -Path \"cert:\\LocalMachine\\My\\$SelfSignedThumb\" -DeleteKey -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed remove self signed cert $_\"\n    }\n}\n\nFunction Set-DscConfiguration {\n    [CmdletBinding()]\n    Param (\n        [Parameter(Mandatory = $true)][String]$ServerRole\n    )\n    Configuration ConfigInstance {\n        Import-DscResource -ModuleName 'AuditPolicyDsc', 'SChannelDsc'\n        Node LocalHost {\n            AuditPolicySubcategory CredentialValidationSuccess {\n                Name      = 'Credential Validation'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory CredentialValidationFailure {\n                Name      = 'Credential Validation'\n                AuditFlag = 'Failure'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory OtherAccountLogonEventsSuccess {\n                Name      = 'Other Account Logon Events'\n                AuditFlag = 'Success'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory OtherAccountLogonEventsFailure {\n                Name      = 'Other Account Logon Events'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory ApplicationGroupManagementSuccess {\n                Name      = 'Application Group Management'\n                AuditFlag = 'Success'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory ApplicationGroupManagementFailure {\n                Name      = 'Application Group Management'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory ComputerAccountManagementFailure {\n                Name      = 'Computer Account Management'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory DistributionGroupManagementFailure {\n                Name      = 'Distribution Group Management'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory OtherAccountManagementEventsSuccess {\n                Name      = 'Other Account Management Events'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory OtherAccountManagementEventsFailure {\n                Name      = 'Other Account Management Events'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory SecurityGroupManagementSuccess {\n                Name      = 'Security Group Management'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory SecurityGroupManagementFailure {\n                Name      = 'Security Group Management'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory UserAccountManagementSuccess {\n                Name      = 'User Account Management'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory UserAccountManagementFailure {\n                Name      = 'User Account Management'\n                AuditFlag = 'Failure'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory DPAPIActivitySuccess {\n                Name      = 'DPAPI Activity'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory DPAPIActivityFailure {\n                Name      = 'DPAPI Activity'\n                AuditFlag = 'Failure'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory PNPActivitySuccess {\n                Name      = 'Plug and Play Events'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory PNPActivityFailure {\n                Name      = 'Plug and Play Events'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory ProcessCreationSuccess {\n                Name      = 'Process Creation'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory ProcessCreationFailure {\n                Name      = 'Process Creation'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory ProcessTerminationSuccess {\n                Name      = 'Process Termination'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory ProcessTerminationFailure {\n                Name      = 'Process Termination'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory RPCEventsSuccess {\n                Name      = 'RPC Events'\n                AuditFlag = 'Success'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory RPCEventsFailure {\n                Name      = 'RPC Events'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory TokenRightAdjustedSuccess {\n                Name      = 'Token Right Adjusted Events'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory TokenRightAdjustedFailure {\n                Name      = 'Token Right Adjusted Events'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory DirectoryServiceAccessSuccess {\n                Name      = 'Directory Service Access'\n                AuditFlag = 'Success'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory DirectoryServiceChangesFailure {\n                Name      = 'Directory Service Changes'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory AccountLockoutSuccess {\n                Name      = 'Account Lockout'\n                AuditFlag = 'Success'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory AccountLockoutFailure {\n                Name      = 'Account Lockout'\n                AuditFlag = 'Failure'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory UserDeviceClaimsSuccess {\n                Name      = 'User / Device Claims'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory UserDeviceClaimsFailure {\n                Name      = 'User / Device Claims'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory GroupMembershipSuccess {\n                Name      = 'Group Membership'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory GroupMembershipFailure {\n                Name      = 'Group Membership'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory IPsecExtendedModeSuccess {\n                Name      = 'IPsec Extended Mode'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory IPsecExtendedModeFailure {\n                Name      = 'IPsec Extended Mode'\n                AuditFlag = 'Failure'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory IPsecMainModeSuccess {\n                Name      = 'IPsec Main Mode'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory IPsecMainModeFailure {\n                Name      = 'IPsec Main Mode'\n                AuditFlag = 'Failure'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory IPsecQuickModeSuccess {\n                Name      = 'IPsec Quick Mode'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory IPsecQuickModeFailure {\n                Name      = 'IPsec Quick Mode'\n                AuditFlag = 'Failure'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory LogoffSuccess {\n                Name      = 'Logoff'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory Logoffailure {\n                Name      = 'Logoff'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory LogonSuccess {\n                Name      = 'Logon'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory LogonFailure {\n                Name      = 'Logon'\n                AuditFlag = 'Failure'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory NetworkPolicyServerSuccess {\n                Name      = 'Network Policy Server'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory NetworkPolicyServerFailure {\n                Name      = 'Network Policy Server'\n                AuditFlag = 'Failure'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory OtherLogonLogoffEventsSuccess {\n                Name      = 'Other Logon/Logoff Events'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory OtherLogonLogoffEventsFailure {\n                Name      = 'Other Logon/Logoff Events'\n                AuditFlag = 'Failure'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory SpecialLogonSuccess {\n                Name      = 'Special Logon'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory SpecialLogonFailure {\n                Name      = 'Special Logon'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory ApplicationGeneratedSuccess {\n                Name      = 'Application Generated'\n                AuditFlag = 'Success'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory ApplicationGeneratedFailure {\n                Name      = 'Application Generated'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory DetailedFileShareFailure {\n                Name      = 'Detailed File Share'\n                AuditFlag = 'Failure'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory FileShareSuccess {\n                Name      = 'File Share'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory FileShareFailure {\n                Name      = 'File Share'\n                AuditFlag = 'Failure'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory FileSystemSuccess {\n                Name      = 'File System'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory FileSystemFailure {\n                Name      = 'File System'\n                AuditFlag = 'Failure'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory FilteringPlatformConnectionSuccess {\n                Name      = 'Filtering Platform Connection'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory FilteringPlatformConnectionFailure {\n                Name      = 'Filtering Platform Connection'\n                AuditFlag = 'Failure'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory FilteringPlatformPacketDropSuccess {\n                Name      = 'Filtering Platform Packet Drop'\n                AuditFlag = 'Success'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory FilteringPlatformPacketDropFailure {\n                Name      = 'Filtering Platform Packet Drop'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory HandleManipulationSuccess {\n                Name      = 'Handle Manipulation'\n                AuditFlag = 'Success'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory HandleManipulationFailure {\n                Name      = 'Handle Manipulation'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory KernelObjectSuccess {\n                Name      = 'Kernel Object'\n                AuditFlag = 'Success'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory KernelObjectFailure {\n                Name      = 'Kernel Object'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory OtherObjectAccessEventsSuccess {\n                Name      = 'Other Object Access Events'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory OtherObjectAccessEventsFailure {\n                Name      = 'Other Object Access Events'\n                AuditFlag = 'Failure'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory RegistrySuccess {\n                Name      = 'Registry'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory RegistryFailure {\n                Name      = 'Registry'\n                AuditFlag = 'Failure'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory RemovableStorageSuccess {\n                Name      = 'Removable Storage'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory RemovableStorageFailure {\n                Name      = 'Removable Storage'\n                AuditFlag = 'Failure'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory CentralAccessPolicyStagingSuccess {\n                Name      = 'Central Policy Staging'\n                AuditFlag = 'Success'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory CentralAccessPolicyStagingFailure {\n                Name      = 'Central Policy Staging'\n                AuditFlag = 'Failure'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory AuditPolicyChangeSuccess {\n                Name      = 'Audit Policy Change'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory AuditPolicyChangeFailure {\n                Name      = 'Audit Policy Change'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory AuthenticationPolicyChangeSuccess {\n                Name      = 'Authentication Policy Change'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory AuthenticationPolicyChangeFailure {\n                Name      = 'Authentication Policy Change'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory AuthorizationPolicyChangeSuccess {\n                Name      = 'Authorization Policy Change'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory AuthorizationPolicyChangeFailure {\n                Name      = 'Authorization Policy Change'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory MPSSVCRule-LevelPolicyChangeSuccess {\n                Name      = 'MPSSVC Rule-Level Policy Change'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory MPSSVCRule-LevelPolicyChangeFailure {\n                Name      = 'MPSSVC Rule-Level Policy Change'\n                AuditFlag = 'Failure'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory OtherPolicyChangeEventsSuccess {\n                Name      = 'Other Policy Change Events'\n                AuditFlag = 'Success'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory OtherPolicyChangeEventsFailure {\n                Name      = 'Other Policy Change Events'\n                AuditFlag = 'Failure'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory NonSensitivePrivilegeUseSuccess {\n                Name      = 'Non Sensitive Privilege Use'\n                AuditFlag = 'Success'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory NonSensitivePrivilegeUseFailure {\n                Name      = 'Non Sensitive Privilege Use'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory OtherPrivilegeUseEventsSuccess {\n                Name      = 'Other Privilege Use Events'\n                AuditFlag = 'Success'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory OtherPrivilegeUseEventsFailure {\n                Name      = 'Other Privilege Use Events'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory SensitivePrivilegeUseSuccess {\n                Name      = 'Sensitive Privilege Use'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory SensitivePrivilegeUseFailure {\n                Name      = 'Sensitive Privilege Use'\n                AuditFlag = 'Failure'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory IPsecDriverSuccess {\n                Name      = 'IPsec Driver'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory IPsecDriverFailure {\n                Name      = 'IPsec Driver'\n                AuditFlag = 'Failure'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory OtherSystemEventsSuccess {\n                Name      = 'Other System Events'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory OtherSystemEventsFailure {\n                Name      = 'Other System Events'\n                AuditFlag = 'Failure'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory SecurityStateChangeSuccess {\n                Name      = 'Security State Change'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory SecurityStateChangeFailure {\n                Name      = 'Security State Change'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory SecuritySystemExtensionSuccess {\n                Name      = 'Security System Extension'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory SecuritySystemExtensionFailure {\n                Name      = 'Security System Extension'\n                AuditFlag = 'Failure'\n                Ensure    = 'Absent'\n            }\n            AuditPolicySubcategory SystemIntegritySuccess {\n                Name      = 'System Integrity'\n                AuditFlag = 'Success'\n                Ensure    = 'Present'\n            }\n            AuditPolicySubcategory SystemIntegrityFailure {\n                Name      = 'System Integrity'\n                AuditFlag = 'Failure'\n                Ensure    = 'Present'\n            }\n            Protocol DisableSSLv3 {\n                Protocol           = 'SSL 3.0'\n                IncludeClientSide  = $true\n                State              = 'Disabled'\n                #RebootWhenRequired = $true\n            }\n            Protocol DisableTLS1 {\n                Protocol           = 'TLS 1.0' \n                IncludeClientSide  = $true\n                State              = 'Disabled'\n                #RebootWhenRequired = $true\n            }\n            Protocol DisableTLS11 {\n                Protocol           = 'TLS 1.1'\n                IncludeClientSide  = $true\n                State              = 'Disabled'\n                #RebootWhenRequired = $true\n            }\n            Protocol EnableTLS12 {\n                Protocol           = 'TLS 1.2'\n                IncludeClientSide  = $true\n                State              = 'Enabled'\n                #RebootWhenRequired = $true\n            }\n            Protocol EnableTLS13 {\n                Protocol           = 'TLS 1.3'\n                IncludeClientSide  = $true\n                State              = 'Enabled'\n                #RebootWhenRequired = $true\n            }    \n            Cipher DisableRC4-40 {\n                Cipher             = 'RC4 40/128'\n                State              = 'Disabled'\n                #RebootWhenRequired = $true\n            }\n            Cipher DisableRC4-56 {\n                Cipher             = 'RC4 56/128'\n                State              = 'Disabled'\n                #RebootWhenRequired = $true\n            }\n            Cipher DisableRC4-64 {\n                Cipher             = 'RC4 64/128'\n                State              = 'Disabled'\n                #RebootWhenRequired = $true\n            }\n            Cipher DisableRC4-128 {\n                Cipher             = 'RC4 128/128'\n                State              = 'Disabled'\n                #RebootWhenRequired = $true\n            }\n            Cipher Disable3Des {\n                Cipher             = 'Triple DES 168'\n                State              = 'Disabled'\n                #RebootWhenRequired = $true\n            }\n            Cipher EnableAES128 {\n                Cipher             = 'AES 128/128'\n                State              = 'Enabled'\n                #RebootWhenRequired = $true\n            }\n            Cipher EnableAES256 {\n                Cipher             = 'AES 256/256'\n                State              = 'Enabled'\n                #RebootWhenRequired = $true\n            }\n            CipherSuites 3DESCipher {\n                IsSingleInstance   = 'Yes'\n                CipherSuitesOrder  = 'TLS_RSA_WITH_3DES_EDE_CBC_SHA'\n                Ensure             = 'Absent'\n                #RebootWhenRequired = $true\n            }\n            SChannelSettings 'ConfigureSChannel' {\n                IsSingleInstance              = 'Yes'\n                TLS12State                    = 'Enabled'\n                WinHttpDefaultSecureProtocols = @('TLS1.2')\n                #RebootWhenRequired            = $true\n            }\n            If ($ServerRole -eq 'DomainController') {\n                AuditPolicySubcategory KerberosAuthenticationServiceSuccess {\n                    Name = 'Kerberos Authentication Service'\n                    AuditFlag = 'Success'\n                    Ensure = 'Present'\n                }\n                AuditPolicySubcategory KerberosAuthenticationServiceFailure {\n                    Name = 'Kerberos Authentication Service'\n                    AuditFlag = 'Failure'\n                    Ensure = 'Present'\n                }\n                AuditPolicySubcategory KerberosServiceTicketOperationsSuccess {\n                    Name = 'Kerberos Service Ticket Operations'\n                    AuditFlag = 'Success'\n                    Ensure = 'Present'\n                }\n                AuditPolicySubcategory KerberosServiceTicketOperationsFailure {\n                    Name = 'Kerberos Service Ticket Operations'\n                    AuditFlag = 'Failure'\n                    Ensure = 'Present'\n                }\n                AuditPolicySubcategory ComputerAccountManagementSuccess {\n                    Name = 'Computer Account Management'\n                    AuditFlag = 'Success'\n                    Ensure = 'Present'\n                }\n                AuditPolicySubcategory DistributionGroupManagementSuccess {\n                    Name = 'Distribution Group Management'\n                    AuditFlag = 'Success'\n                    Ensure = 'Present'\n                }\n                AuditPolicySubcategory DetailedDirectoryServiceReplicationSuccess {\n                    Name = 'Detailed Directory Service Replication'\n                    AuditFlag = 'Success'\n                    Ensure = 'Present'\n                }\n                AuditPolicySubcategory DetailedDirectoryServiceReplicationFailure {\n                    Name = 'Detailed Directory Service Replication'\n                    AuditFlag = 'Failure'\n                    Ensure = 'Present'\n                }\n                AuditPolicySubcategory DirectoryServiceAccessFailure {\n                    Name = 'Directory Service Access'\n                    AuditFlag = 'Failure'\n                    Ensure = 'Present'\n                }\n                AuditPolicySubcategory DirectoryServiceChangesSuccess {\n                    Name = 'Directory Service Changes'\n                    AuditFlag = 'Success'\n                    Ensure = 'Present'\n                }\n                AuditPolicySubcategory DirectoryServiceReplicationSuccess {\n                    Name = 'Directory Service Replication'\n                    AuditFlag = 'Success'\n                    Ensure = 'Present'\n                }\n                AuditPolicySubcategory DirectoryServiceReplicationFailure {\n                    Name = 'Directory Service Replication'\n                    AuditFlag = 'Failure'\n                    Ensure = 'Present'\n                }\n                \n                AuditPolicySubcategory DetailedFileShareSuccess {\n                    Name = 'Detailed File Share'\n                    AuditFlag = 'Success'\n                    Ensure = 'Absent'\n                }\n            } Else {\n                AuditPolicySubcategory KerberosAuthenticationServiceSuccess {\n                    Name = 'Kerberos Authentication Service'\n                    AuditFlag = 'Success'\n                    Ensure = 'Absent'\n                }\n                AuditPolicySubcategory KerberosAuthenticationServiceFailure {\n                    Name = 'Kerberos Authentication Service'\n                    AuditFlag = 'Failure'\n                    Ensure = 'Absent'\n                }\n                AuditPolicySubcategory KerberosServiceTicketOperationsSuccess {\n                    Name = 'Kerberos Service Ticket Operations'\n                    AuditFlag = 'Success'\n                    Ensure = 'Absent'\n                }\n                AuditPolicySubcategory KerberosServiceTicketOperationsFailure {\n                    Name = 'Kerberos Service Ticket Operations'\n                    AuditFlag = 'Failure'\n                    Ensure = 'Absent'\n                }\n                AuditPolicySubcategory ComputerAccountManagementSuccess {\n                    Name = 'Computer Account Management'\n                    AuditFlag = 'Success'\n                    Ensure = 'Absent'\n                }\n                AuditPolicySubcategory DistributionGroupManagementSuccess {\n                    Name = 'Distribution Group Management'\n                    AuditFlag = 'Success'\n                    Ensure = 'Absent'\n                }\n                AuditPolicySubcategory DetailedDirectoryServiceReplicationSuccess {\n                    Name = 'Detailed Directory Service Replication'\n                    AuditFlag = 'Success'\n                    Ensure = 'Absent'\n                }\n                AuditPolicySubcategory DetailedDirectoryServiceReplicationFailure {\n                    Name = 'Detailed Directory Service Replication'\n                    AuditFlag = 'Failure'\n                    Ensure = 'Absent'\n                }\n                AuditPolicySubcategory DirectoryServiceAccessFailure {\n                    Name = 'Directory Service Access'\n                    AuditFlag = 'Failure'\n                    Ensure = 'Absent'\n                }\n                AuditPolicySubcategory DirectoryServiceChangesSuccess {\n                    Name = 'Directory Service Changes'\n                    AuditFlag = 'Success'\n                    Ensure = 'Absent'\n                }\n                AuditPolicySubcategory DirectoryServiceReplicationSuccess {\n                    Name = 'Directory Service Replication'\n                    AuditFlag = 'Success'\n                    Ensure = 'Absent'\n                }\n                AuditPolicySubcategory DirectoryServiceReplicationFailure {\n                    Name = 'Directory Service Replication'\n                    AuditFlag = 'Failure'\n                    Ensure = 'Absent'\n                }\n                AuditPolicySubcategory DetailedFileShareSuccess {\n                    Name = 'Detailed File Share'\n                    AuditFlag = 'Success'\n                    Ensure = 'Present'\n                }\n            }\n            If ($ServerRole -eq 'CertificateAuthority') {\n                AuditPolicySubcategory CertificationServicesSuccess {\n                    Name = 'Certification Services'\n                    AuditFlag = 'Success'\n                    Ensure = 'Present'\n                }\n                AuditPolicySubcategory CertificationServicesFailure {\n                    Name = 'Certification Services'\n                    AuditFlag = 'Failure'\n                    Ensure = 'Present'\n                }    \n            } Else { \n                AuditPolicySubcategory CertificationServicesSuccess {\n                    Name = 'Certification Services'\n                    AuditFlag = 'Success'\n                    Ensure = 'Absent'\n                }\n                AuditPolicySubcategory CertificationServicesFailure {\n                    Name = 'Certification Services'\n                    AuditFlag = 'Failure'\n                    Ensure = 'Absent'\n                }\n            }\n        }\n    }\n    Write-Output 'Generating MOF file'\n    $Null = ConfigInstance -OutputPath 'C:\\Temp\\AuditConfigInstance' -ConfigurationData $ConfigurationData\n}\n\nFunction Invoke-DscStatusCheck {\n    $LCMState = Get-DscLocalConfigurationManager -ErrorAction SilentlyContinue | Select-Object -ExpandProperty 'LCMState'\n    If ($LCMState -eq 'PendingConfiguration' -Or $LCMState -eq 'PendingReboot') {\n        Exit 3010\n    } Else {\n        Write-Output 'DSC Config Completed'\n    }\n}\n\n$AuditConfigPresent = Test-Path -Path 'C:\\Temp\\AuditConfigInstance'\nSet-DscConfiguration -ServerRole '{{ServerRole}}'\n\nIf ($AuditConfigPresent) {\n    Start-DscConfiguration -UseExisting -Wait -Verbose -Force\n} Else {\n    Start-DscConfiguration 'C:\\Temp\\AuditConfigInstance' -Wait -Verbose -Force\n}\n\nInvoke-DscStatusCheck\n\nTry {\n    $Version = (Invoke-WebRequest 'https://s3-us-west-2.amazonaws.com/kinesis-agent-windows/downloads/packages.json' -Headers @{\"Accept\"=\"application/json\"} -UseBasicParsing | Select-Object -ExpandProperty 'Content' | ConvertFrom-Json | Select-Object -ExpandProperty 'Packages').Version[0]\n} Catch [System.Exception] {\n    Write-Output \"Failed to get latest KTAP version $_\"\n    Exit 1\n}\n\n(New-Object -TypeName 'System.Net.WebClient').DownloadFile(\"https://s3-us-west-2.amazonaws.com/kinesis-agent-windows/downloads/AWSKinesisTap.$Version.msi\", 'C:\\Temp\\AWSKinesisTap.msi')\n\nWrite-Output 'Installing KinesisTap'\n$Process = Start-Process -FilePath 'msiexec.exe' -ArgumentList '/I C:\\Temp\\AWSKinesisTap.msi /quiet /l C:\\Temp\\ktap-install-log.txt' -NoNewWindow -PassThru -Wait -ErrorAction Stop\n\nIf ($Process.ExitCode -ne 0) {\n    Write-Output \"Error installing KinesisTap -exit code $($Process.ExitCode)\"\n    Exit 1\n}\n\nIf ($ServerRole -eq 'DomainController') {\n    $DcCategories = @(\n        @{\n            'Category' = 'ADWS'\n            'Counters' = @(\n                @{\n                    'Counter' = 'Active Web Service Sessions'\n                    'Unit'    = 'Count'\n                },\n                @{\n                    'Counter' = 'ChangePassword Operations Per Second'\n                    'Unit'    = 'Count/Second'\n                }\n                @{\n                    'Counter' = 'Delete Operations Per Second'\n                    'Unit'    = 'Count/Second'\n                },\n                @{\n                    'Counter' = 'SetPassword Operations Per Second'\n                    'Unit'    = 'Count/Second'\n                }\n            )\n        },\n        @{\n            'Category'  = 'Database ==> Instances'\n            'Instances' = 'NTDSA'\n            'Counters'  = @(\n                @{\n                    'Counter' = 'Database Cache % Hit'\n                    'Unit'    = 'Percent'\n                },\n                @{\n                    'Counter' = 'Database Cache Size (MB)'\n                    'Unit'    = 'Megabytes'\n                },\n                @{\n                    'Counter' = 'I/O Database Reads Average Latency'\n                    'Unit'    = 'Milliseconds'\n                },\n                @{\n                    'Counter' = 'I/O Database Reads/sec'\n                    'Unit'    = 'Count/Second'\n                },\n                @{\n                    'Counter' = 'I/O Log Writes Average Latency'\n                    'Unit'    = 'Milliseconds'\n                },\n                @{\n                    'Counter' = 'I/O Database Writes/sec'\n                    'Unit'    = 'Count/Second'\n                }\n            )\n        },\n        @{\n            'Category'  = 'DFS Replication Service Volumes'\n            'Instances' = '*'\n            'Counters'  = @(\n                @{\n                    'Counter' = 'USN Journal Unread Percentage'\n                    'Unit'    = 'Percent'\n                }\n            )\n        },\n        @{\n            'Category' = 'DNS'\n            'Counters' = @(\n                @{\n                    'Counter' = 'Dynamic Update Rejected'\n                    'Unit'    = 'Count'\n                },\n                @{\n                    'Counter' = 'Recursive Queries/sec'\n                    'Unit'    = 'Count/Second'\n                },\n                @{\n                    'Counter' = 'Recursive Query Failure/sec'\n                    'Unit'    = 'Count/Second'\n                },\n                @{\n                    'Counter' = 'Secure Update Failure'\n                    'Unit'    = 'Count'\n                },\n                @{\n                    'Counter' = 'TCP Query Received/sec'\n                    'Unit'    = 'Count/Second'\n                },\n                @{\n                    'Counter' = 'Total Query Received/sec'\n                    'Unit'    = 'Count/Second'\n                },\n                @{\n                    'Counter' = 'Total Response Sent/sec'\n                    'Unit'    = 'Count/Second'\n                },\n                @{\n                    'Counter' = 'UDP Query Received/sec'\n                    'Unit'    = 'Count/Second'\n                }\n            )\n        },\n        @{\n            'Category' = 'NTDS'\n            'Counters' = @(\n                @{\n                    'Counter' = 'ATQ Estimated Queue Delay'\n                    'Unit'    = 'Milliseconds'\n                },\n                @{\n                    'Counter' = 'ATQ Request Latency'\n                    'Unit'    = 'Milliseconds'\n                },\n                @{\n                    'Counter' = 'DRA Pending Replication Operations'\n                    'Unit'    = 'Count'\n                },\n                @{\n                    'Counter' = 'DRA Pending Replication Synchronizations'\n                    'Unit'    = 'Count'\n                },\n                @{\n                    'Counter' = 'DS Directory Reads/Sec'\n                    'Unit'    = 'Count/Second'\n                },\n                @{\n                    'Counter' = 'DS Directory Searches/Sec'\n                    'Unit'    = 'Count/Second'\n                },\n                @{\n                    'Counter' = 'DS Directory Writes/Sec'\n                    'Unit'    = 'Count/Second'\n                },\n                @{\n                    'Counter' = 'LDAP Bind Time'\n                    'Unit'    = 'Milliseconds'\n                },\n                @{\n                    'Counter' = 'LDAP Client Sessions'\n                    'Unit'    = 'Count'\n                },\n                @{\n                    'Counter' = 'LDAP Searches/sec'\n                    'Unit'    = 'Count/Second'\n                },\n                @{\n                    'Counter' = 'LDAP Successful Binds/sec'\n                    'Unit'    = 'Count/Second'\n                }\n            )\n        },\n        @{\n            'Category' = 'Security System-Wide Statistics'\n            'Counters' = @(\n                @{\n                    'Counter' = 'Kerberos Authentications'\n                    'Unit'    = 'Count/Second'\n                },\n                @{\n                    'Counter' = 'NTLM Authentications'\n                    'Unit'    = 'Count/Second'\n                }\n            )\n        }\n    )\n\n    $DcSources = @(\n        @{\n            'Id'         = 'DFSReplicationLog'\n            'SourceType' = 'WindowsEventLogSource'\n            'LogName'    = 'DFS Replication'\n        },\n        @{\n            'Id'         = 'DirectoryServiceLog'\n            'SourceType' = 'WindowsEventLogSource'\n            'LogName'    = 'Directory Service'\n        },\n        @{\n            'Id'         = 'DNSServerLog'\n            'SourceType' = 'WindowsEventLogSource'\n            'LogName'    = 'DNS Server'\n        },\n        @{\n            'Id'         = 'DNSServerAuditLog'\n            'SourceType' = 'WindowsEventLogSource'\n            'LogName'    = 'Microsoft-Windows-DNSServer/Audit'\n        },\n        @{\n            'Id'         = 'KerberosOperationalLog'\n            'SourceType' = 'WindowsEventLogSource'\n            'LogName'    = 'Microsoft-Windows-Kerberos/Operational'\n        },\n        @{\n            'Id'         = 'Kerberos-Key-Distribution-CenterOperationalLog'\n            'SourceType' = 'WindowsEventLogSource'\n            'LogName'    = 'Microsoft-Windows-Kerberos-Key-Distribution-Center/Operational'\n        },\n        @{\n            'Id'         = 'NTLMOperationalLog'\n            'SourceType' = 'WindowsEventLogSource'\n            'LogName'    = 'Microsoft-Windows-NTLM/Operational'\n        },\n        @{\n            'Id'         = 'Security-NetlogonOperationalLog'\n            'SourceType' = 'WindowsEventLogSource'\n            'LogName'    = 'Microsoft-Windows-Security-Netlogon/Operational'\n        },\n        @{\n            'Id'             = 'DNSLogs'\n            'SourceType'     = 'DirectorySource'\n            'Directory'      = 'C:\\DnsLogs'\n            'FileNameFilter' = '*.log|*.txt'\n            'RecordParser'   = 'SingleLine'\n        }\n    )\n\n    $DcSinks = @(\n        @{\n            'Id'             = 'DFSReplicationLog-CloudWatchLogsSink'\n            'SinkType'       = 'CloudWatchLogs'\n            'BufferInterval' = '60'\n            'LogGroup'       = '{ComputerName}-Log-Group'\n            'LogStream'      = 'DFSReplicationLog-Stream'\n            'Region'         = 'ReplaceMe'\n            'Format'         = 'json'\n        },\n        @{\n            'Id'             = 'DirectoryServiceLog-CloudWatchLogsSink'\n            'SinkType'       = 'CloudWatchLogs'\n            'BufferInterval' = '60'\n            'LogGroup'       = '{ComputerName}-Log-Group'\n            'LogStream'      = 'DirectoryServiceLog-Stream'\n            'Region'         = 'ReplaceMe'\n            'Format'         = 'json'\n        },\n        @{\n            'Id'             = 'DNSServerLog-CloudWatchLogsSink'\n            'SinkType'       = 'CloudWatchLogs'\n            'BufferInterval' = '60'\n            'LogGroup'       = '{ComputerName}-Log-Group'\n            'LogStream'      = 'DNSServerLog-Stream'\n            'Region'         = 'ReplaceMe'\n            'Format'         = 'json'\n        },\n        @{\n            'Id'             = 'DNSServerAuditLog-CloudWatchLogsSink'\n            'SinkType'       = 'CloudWatchLogs'\n            'BufferInterval' = '60'\n            'LogGroup'       = '{ComputerName}-Log-Group'\n            'LogStream'      = 'DNSServerAuditLog-Stream'\n            'Region'         = 'ReplaceMe'\n            'Format'         = 'json'\n        },\n        @{\n            'Id'             = 'KerberosOperationalLog-CloudWatchLogsSink'\n            'SinkType'       = 'CloudWatchLogs'\n            'BufferInterval' = '60'\n            'LogGroup'       = '{ComputerName}-Log-Group'\n            'LogStream'      = 'KerberosOperationalLog-Stream'\n            'Region'         = 'ReplaceMe'\n            'Format'         = 'json'\n        },\n        @{\n            'Id'             = 'Kerberos-Key-Distribution-CenterOperationalLog-CloudWatchLogsSink'\n            'SinkType'       = 'CloudWatchLogs'\n            'BufferInterval' = '60'\n            'LogGroup'       = '{ComputerName}-Log-Group'\n            'LogStream'      = 'Kerberos-Key-Distribution-CenterOperationalLog-Stream'\n            'Region'         = 'ReplaceMe'\n            'Format'         = 'json'\n        },\n        @{\n            'Id'             = 'NTLMOperationalLog-CloudWatchLogsSink'\n            'SinkType'       = 'CloudWatchLogs'\n            'BufferInterval' = '60'\n            'LogGroup'       = '{ComputerName}-Log-Group'\n            'LogStream'      = 'NTLMOperationalLog-Stream'\n            'Region'         = 'ReplaceMe'\n            'Format'         = 'json'\n        },\n        @{\n            'Id'             = 'Security-NetlogonOperationalLog-CloudWatchLogsSink'\n            'SinkType'       = 'CloudWatchLogs'\n            'BufferInterval' = '60'\n            'LogGroup'       = '{ComputerName}-Log-Group'\n            'LogStream'      = 'Security-NetlogonOperationalLog-Stream'\n            'Region'         = 'ReplaceMe'\n            'Format'         = 'json'\n        },\n        @{\n            'Id'             = 'DNSLogs-CloudWatchLogsSink'\n            'SinkType'       = 'CloudWatchLogs'\n            'BufferInterval' = '60'\n            'LogGroup'       = '{ComputerName}-Log-Group'\n            'LogStream'      = 'DNSLogs-Stream'\n            'Region'         = 'ReplaceMe'\n            'Format'         = 'json'\n        }\n    )\n\n    $DcPipes = @(\n        @{\n            'Id'        = 'DFSReplicationLogToCloudWatch'\n            'SourceRef' = 'DFSReplicationLog'\n            'SinkRef'   = 'DFSReplicationLog-CloudWatchLogsSink'\n        },\n        @{\n            'Id'        = 'DirectoryServiceLogToCloudWatch'\n            'SourceRef' = 'DirectoryServiceLog'\n            'SinkRef'   = 'DirectoryServiceLog-CloudWatchLogsSink'\n        },\n        @{\n            'Id'        = 'DNSServerLogToCloudWatch'\n            'SourceRef' = 'DNSServerLog'\n            'SinkRef'   = 'DNSServerLog-CloudWatchLogsSink'\n        },\n        @{\n            'Id'        = 'DNSServerAuditLogToCloudWatch'\n            'SourceRef' = 'DNSServerAuditLog'\n            'SinkRef'   = 'DNSServerAuditLog-CloudWatchLogsSink'\n        },\n        @{\n            'Id'        = 'KerberosOperationalLogToCloudWatch'\n            'SourceRef' = 'KerberosOperationalLog'\n            'SinkRef'   = 'KerberosOperationalLog-CloudWatchLogsSink'\n        },\n        @{\n            'Id'        = 'Kerberos-Key-Distribution-CenterOperationalLogToCloudWatch'\n            'SourceRef' = 'Kerberos-Key-Distribution-CenterOperationalLog'\n            'SinkRef'   = 'Kerberos-Key-Distribution-CenterOperationalLog-CloudWatchLogsSink'\n        },\n        @{\n            'Id'        = 'NTLMOperationalLogToCloudWatch'\n            'SourceRef' = 'NTLMOperationalLog'\n            'SinkRef'   = 'NTLMOperationalLog-CloudWatchLogsSink'\n        },\n        @{\n            'Id'        = 'Security-NetlogonOperationalLogToCloudWatch'\n            'SourceRef' = 'Security-NetlogonOperationalLog'\n            'SinkRef'   = 'Security-NetlogonOperationalLog-CloudWatchLogsSink'\n        },\n        @{\n            'Id'        = 'DNSLogsToCloudWatch'\n            'SourceRef' = 'DNSLogs'\n            'SinkRef'   = 'DNSLogs-CloudWatchLogsSink'\n        }\n    )\n}\n\nIf ($ServerRole -eq 'CertificateAuthority') {\n    $CaCategories = @(\n        @{\n            'Category'  = 'Certification Authority'\n            'Instances' = '*'\n            'Counters'  = @(\n                @{\n                    'Counter' = 'Failed Request/sec'\n                    'Unit'    = 'Count/Second'\n                },\n                @{\n                    'Counter' = 'Request/sec'\n                    'Unit'    = 'Count/Second'\n                },\n                @{\n                    'Counter' = 'Request processing time (ms)'\n                    'Unit'    = 'Milliseconds'\n                }\n            )\n        },\n        @{\n            'Category'  = 'Certification Authority Connections'\n            'Instances' = '*'\n            'Counters'  = @(\n                @{\n                    'Counter' = 'Active connections'\n                    'Unit'    = 'Count'\n                }\n            )\n        }\n    )\n}\n\n$KenesisAgentSettings = @{\n    'Sources'    = @(\n        @{\n            'Id'         = 'PerformanceCounter'\n            'SourceType' = 'WindowsPerformanceCounterSource'\n            'Categories' = @(\n                @{\n                    'Category'  = 'ENA Packets Shaping'\n                    'Instances' = 'ENA #1'\n                    'Counters'  = @(\n                        @{\n                            'Counter' = 'Aggregate inbound BW allowance exceeded'\n                            'Unit'    = 'Count'\n                        },\n                        @{\n                            'Counter' = 'Aggregate outbound BW allowance exceeded'\n                            'Unit'    = 'Count'\n                        },\n                        @{\n                            'Counter' = 'Connection tracking allowance exceeded'\n                            'Unit'    = 'Count'\n                        },\n                        @{\n                            'Counter' = 'Link local packet rate allowance exceeded'\n                            'Unit'    = 'Count'\n                        },\n                        @{\n                            'Counter' = 'PPS allowance exceeded'\n                            'Unit'    = 'Count'\n                        }\n                    )\n                },\n                @{\n                    'Category'  = 'LogicalDisk'\n                    'Instances' = 'D:'\n                    'Counters'  = @(\n                        @{\n                            'Counter' = '% Free Space'\n                            'Unit'    = 'Percent'\n                        },\n                        @{\n                            'Counter' = 'Avg. Disk Queue Length'\n                            'Unit'    = 'Count'\n                        }\n                    )\n                },\n                @{\n                    'Category'  = 'LogicalDisk'\n                    'Instances' = 'C:'\n                    'Counters'  = @(\n                        @{\n                            'Counter' = '% Free Space'\n                            'Unit'    = 'Percent'\n                        },\n                        @{\n                            'Counter' = 'Avg. Disk Queue Length'\n                            'Unit'    = 'Count'\n                        }\n                    )\n                },\n                @{\n                    'Category' = 'Memory'\n                    'Counters' = @(\n                        @{\n                            'Counter' = '% Committed Bytes in Use'\n                            'Unit'    = 'Percent'\n                        },\n                        @{\n                            'Counter' = 'Available MBytes'\n                            'Unit'    = 'Megabytes'\n                        },\n                        @{\n                            'Counter' = 'Long-Term Average Standby Cache Lifetime (s)'\n                            'Unit'    = 'Seconds'\n                        }\n                    )\n                },\n                @{\n                    'Category'  = 'Network Interface'\n                    'Instances' = 'Amazon Elastic Network Adapter'\n                    'Counters'  = @(\n                        @{\n                            'Counter' = 'Bytes Received/sec'\n                            'Unit'    = 'Count/Second'\n                        },\n                        @{\n                            'Counter' = 'Bytes Sent/sec'\n                            'Unit'    = 'Count/Second'\n                        },\n                        @{\n                            'Counter' = 'Current Bandwidth'\n                            'Unit'    = 'Bits/Second'\n                        }\n                    )\n                },\n                @{\n                    'Category'  = 'PhysicalDisk'\n                    'Instances' = '0 C:'\n                    'Counters'  = @(\n                        @{\n                            'Counter' = 'Avg. Disk Queue Length'\n                            'Unit'    = 'Count'\n                        }\n                    )\n                },\n                @{\n                    'Category'  = 'PhysicalDisk'\n                    'Instances' = '1 D:'\n                    'Counters'  = @(\n                        @{\n                            'Counter' = 'Avg. Disk Queue Length'\n                            'Unit'    = 'Count'\n                        }\n                    )\n                },\n                @{\n                    'Category'  = 'Processor'\n                    'Instances' = '*'\n                    'Counters'  = @(\n                        @{\n                            'Counter' = '% Processor Time'\n                            'Unit'    = 'Percent'\n                        }\n                    )\n                }\n                $DcCategories\n                $CaCategories\n            )\n        },\n        @{\n            'Id'         = 'ApplicationLog'\n            'SourceType' = 'WindowsEventLogSource'\n            'LogName'    = 'Application'\n        },\n        @{\n            'Id'         = 'SecurityLog'\n            'SourceType' = 'WindowsEventLogSource'\n            'LogName'    = 'Security'\n        },\n        @{\n            'Id'         = 'SystemLog'\n            'SourceType' = 'WindowsEventLogSource'\n            'LogName'    = 'System'\n        },\n        @{\n            'Id'         = 'CertificateServicesClient-Lifecycle-SystemOperationalLog'\n            'SourceType' = 'WindowsEventLogSource'\n            'LogName'    = 'Microsoft-Windows-CertificateServicesClient-Lifecycle-System/Operational'\n        }\n        $DcSources\n    )\n    'Sinks'      = @(\n        @{\n            'Namespace' = 'EC2-Domain-Member-Metrics'\n            'Region'    = 'ReplaceMe'\n            'Id'        = 'CloudWatchSink'\n            'Interval'  = '60'\n            'SinkType'  = 'CloudWatch'\n        },\n        @{\n            'Id'             = 'ApplicationLog-CloudWatchLogsSink'\n            'SinkType'       = 'CloudWatchLogs'\n            'BufferInterval' = '60'\n            'LogGroup'       = '{ComputerName}-Log-Group'\n            'LogStream'      = 'ApplicationLog-Stream'\n            'Region'         = 'ReplaceMe'\n            'Format'         = 'json'\n        },\n        @{\n            'Id'             = 'SecurityLog-CloudWatchLogsSink'\n            'SinkType'       = 'CloudWatchLogs'\n            'BufferInterval' = '60'\n            'LogGroup'       = '{ComputerName}-Log-Group'\n            'LogStream'      = 'SecurityLog-Stream'\n            'Region'         = 'ReplaceMe'\n            'Format'         = 'json'\n        },\n        @{\n            'Id'             = 'SystemLog-CloudWatchLogsSink'\n            'SinkType'       = 'CloudWatchLogs'\n            'BufferInterval' = '60'\n            'LogGroup'       = '{ComputerName}-Log-Group'\n            'LogStream'      = 'SystemLog-Stream'\n            'Region'         = 'ReplaceMe'\n            'Format'         = 'json'\n        },\n        @{\n            'Id'             = 'CertificateServicesClient-Lifecycle-SystemOperationalLog-CloudWatchLogsSink'\n            'SinkType'       = 'CloudWatchLogs'\n            'BufferInterval' = '60'\n            'LogGroup'       = '{ComputerName}-Log-Group'\n            'LogStream'      = 'CertificateServicesClient-Lifecycle-SystemOperationalLog-Stream'\n            'Region'         = 'ReplaceMe'\n            'Format'         = 'json'\n        }\n        $DcSinks\n    )\n    'Pipes'      = @(\n        @{\n            'Id'        = 'PerformanceCounterToCloudWatch'\n            'SourceRef' = 'PerformanceCounter'\n            'SinkRef'   = 'CloudWatchSink'\n        },\n        @{\n            'Id'        = 'ApplicationLogToCloudWatch'\n            'SourceRef' = 'ApplicationLog'\n            'SinkRef'   = 'ApplicationLog-CloudWatchLogsSink'\n        },\n        @{\n            'Id'        = 'SecurityLogToCloudWatch'\n            'SourceRef' = 'SecurityLog'\n            'SinkRef'   = 'SecurityLog-CloudWatchLogsSink'\n        },\n        @{\n            'Id'        = 'SystemLogToCloudWatch'\n            'SourceRef' = 'SystemLog'\n            'SinkRef'   = 'SystemLog-CloudWatchLogsSink'\n        },\n        @{\n            'Id'        = 'CertificateServicesClient-Lifecycle-SystemOperationalLogToCloudWatch'\n            'SourceRef' = 'CertificateServicesClient-Lifecycle-SystemOperationalLog'\n            'SinkRef'   = 'CertificateServicesClient-Lifecycle-SystemOperationalLog-CloudWatchLogsSink'\n        }\n        $DcPipes\n    )\n    'SelfUpdate' = 0\n}\n\nWrite-Output 'Getting region'\nTry {\n    [string]$Token = Invoke-RestMethod -Headers @{'X-aws-ec2-metadata-token-ttl-seconds' = '3600' } -Method 'PUT' -Uri 'http://169.254.169.254/latest/api/token' -UseBasicParsing -ErrorAction Stop\n    $Region = (Invoke-RestMethod -Headers @{'X-aws-ec2-metadata-token' = $Token } -Method 'GET' -Uri 'http://169.254.169.254/latest/dynamic/instance-identity/document' -UseBasicParsing -ErrorAction Stop | Select-Object -ExpandProperty 'Region').ToUpper()\n} Catch [System.Exception] {\n    Write-Output \"Failed to get region $_\"\n    Exit 1\n}\n\n$KenesisAgentSettings.Sinks | Where-Object { $_.Region -eq 'ReplaceMe' } | ForEach-Object { $_.Region = $Region }\n\nWrite-Output 'Exporting appsettings.json content'\nTry {\n    $KenesisAgentSettings | ConvertTo-Json -Depth 10 -ErrorAction Stop | Out-File 'C:\\Program Files\\Amazon\\AWSKinesisTap\\appsettings.json' -Encoding 'ascii' -ErrorAction Stop\n} Catch [System.Exception] {\n    Write-Output \"Unable to export appsettings.json $_\"\n    Exit 1\n}\n\nWrite-Output 'Restarting AWSKinesisTap service'\nTry {\n    Restart-Service 'AWSKinesisTap' -Force\n} Catch [System.Exception] {\n    Write-Output \"Unable to restart AWSKinesisTap $_\"\n    Exit 1\n}\n\nInvoke-Cleanup -VPCCIDR '{{VPCCIDR}}'"
            },
            "CloudWatchOutputConfig": {
              "CloudWatchOutputEnabled": true,
              "CloudWatchLogGroupName": "/aws/SSM-AuditPol-${var.ssm_docs_random_string}"
            },
            "InstanceIds": [
              "{{InstanceId.InstanceId}}"
            ],
            "DocumentName": "AWS-RunPowerShellScript"
          },
          "name": "configureInstance",
          "action": "aws:runCommand"
        }
      ]
    }
DOC
}

resource "aws_ssm_document" "ssm_pki" {
  name            = "SSM-Pki-${var.ssm_docs_random_string}"
  document_format = "JSON"
  document_type   = "Automation"
  content         = <<DOC
    {
      "schemaVersion": "0.3",
      "description": "Deploy Enterpise CA",
      "parameters": {
        "ServerNetBIOSName": {
          "description": "NetBIOS name of the first Active Directory Domain Controller (up to 15 characters)",
          "type": "String"
        },
        "DomainType": {
          "description": "Type of domain PKI will be integrated with",
          "type": "String"
        },
        "DomainNetBIOSName": {
          "description": "NetBIOS name of the domain (up to 15 characters) for users of earlier versions of Windows e.g. ONPREMISES",
          "type": "String"
        },
        "VPCCIDR": {
          "description": "CIDR Block for the VPC",
          "type": "String"
        },
        "AdministratorSecretName": {
          "description": "AWS Secrets Parameter Name",
          "type": "String"
        },
        "DeploymentType": {
          "description": "Type of workload being deployed",
          "type": "String"
        },
        "StackName": {
          "description": "Stack Name Input for cfn resource signal",
          "type": "String"
        }
      },
      "mainSteps": [
        {
          "outputs": [
            {
              "Type": "String",
              "Name": "InstanceId",
              "Selector": "$.Reservations[0].Instances[0].InstanceId"
            }
          ],
          "inputs": {
            "Filters": [
              {
                "Values": [
                  "{{ServerNetBIOSName}}"
                ],
                "Name": "tag:Name"
              },
              {
                "Values": [
                  "{{StackName}}"
                ],
                "Name": "tag:aws:cloudformation:stack-name"
              },
              {
                "Values": [
                  "running"
                ],
                "Name": "instance-state-name"
              }
            ],
            "Service": "ec2",
            "Api": "DescribeInstances"
          },
          "name": "InstanceId",
          "action": "aws:executeAwsApi",
          "nextStep": "configureInstance"
        },
        {
          "inputs": {
            "Parameters": {
              "commands": "Function Get-SecretInfo {\n    [CmdletBinding()]\n    Param (\n        [Parameter(Mandatory = $True)][String]$Domain,\n        [Parameter(Mandatory = $True)][String]$SecretArn\n    )\n\n    Write-Output \"Getting $SecretArn Secret\"\n    Try {\n        $SecretContent = Get-SECSecretValue -SecretId $SecretArn -ErrorAction Stop | Select-Object -ExpandProperty 'SecretString' | ConvertFrom-Json -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed to get $SecretArn Secret $_\"\n        Exit 1\n    }\n\n    Write-Output 'Creating PSCredential object from Secret'\n    $Username = $SecretContent.username\n    $UserPassword = ConvertTo-SecureString ($SecretContent.password) -AsPlainText -Force\n    $DomainCredentials = New-Object -TypeName 'System.Management.Automation.PSCredential' (\"$Domain\\$Username\", $UserPassword)\n    $Credentials = New-Object -TypeName 'System.Management.Automation.PSCredential' ($Username, $UserPassword)\n\n    $Output = [PSCustomObject][Ordered]@{\n        'Credentials'       = $Credentials\n        'DomainCredentials' = $DomainCredentials\n        'Username'          = $Username\n        'UserPassword'      = $UserPassword\n    }\n\n    Return $Output\n}\n\nFunction Invoke-EnterpriseCaConfig {\n    [CmdletBinding()]\n    Param (\n        [Parameter(Mandatory = $true)][System.Management.Automation.PSCredential]$Credentials,\n        [Parameter(Mandatory = $true)][String]$DomainType,\n        [Parameter(Mandatory = $true)][String]$EntCaCommonName,\n        [Parameter(Mandatory = $true)][ValidateSet('SHA256', 'SHA384', 'SHA512')][String]$EntCaHashAlgorithm,\n        [Parameter(Mandatory = $true)][ValidateSet('2048', '4096')][String]$EntCaKeyLength,\n        [Parameter(Mandatory = $true)][String]$EntCaValidityPeriodUnits,\n        [Parameter(Mandatory = $true)][String]$VPCCIDR\n    )\n\n    $CompName = $env:COMPUTERNAME\n    $Folders = @(\n        'D:\\Pki\\Req',\n        'D:\\ADCS\\DB',\n        'D:\\ADCS\\Log'\n    )\n    $FilePath = 'D:\\Pki'\n    $Principals = @(\n        'ANONYMOUS LOGON',\n        'EVERYONE'\n    )\n\n    Write-Output 'Installing Windows Features'\n    Try {\n        Install-WindowsFeature -Name 'Adcs-Cert-Authority', 'RSAT-AD-Tools', 'RSAT-DNS-Server', 'Web-WebServer' -IncludeManagementTools -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed to install Windows Features $_\"\n        Exit 1\n    }\n\n    Write-Output 'Getting AD domain'\n    Try {\n        $Domain = Get-ADDomain -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed to get AD domain $_\"\n        Exit 1\n    }\n    $BaseDn = $Domain | Select-Object -ExpandProperty 'DistinguishedName'\n    $FQDN = $Domain | Select-Object -ExpandProperty 'DNSRoot'\n    $Netbios = $Domain | Select-Object -ExpandProperty 'NetBIOSName'\n\n    Write-Output 'Getting a domain controller to perform actions against'\n    Try {\n        $DC = Get-ADDomainController -Discover -ForceDiscover -ErrorAction Stop | Select-Object -ExpandProperty 'HostName'\n    } Catch [System.Exception] {\n        Write-Output \"Failed to get a domain controller $_\"\n        Exit 1\n    }\n\n    $Counter = 0\n    Do {\n        $ARecordPresent = Resolve-DnsName -Name \"$CompName.$FQDN\" -DnsOnly -Server $DC -ErrorAction SilentlyContinue\n        If (-not $ARecordPresent) {\n            $Counter ++\n            Write-Output 'A record missing, registering it.'\n            Register-DnsClient\n            If ($Counter -gt '1') {\n                Start-Sleep -Seconds 10\n            }\n        }\n    } Until ($ARecordPresent -or $Counter -eq 12)\n\n    If ($Counter -ge 12) {\n        Write-Output 'A record never created'\n        Exit 1\n    }\n\n    If ($DomainType -eq 'AWSManagedAD') {\n        Set-CredSSP -Action 'Enable'\n    }\n\n    Write-Output 'Creating PKI CNAME record'\n    $Counter = 0\n    Do {\n        $CnameRecordPresent = Resolve-DnsName -Name \"PKI.$FQDN\" -DnsOnly -Server $DC -ErrorAction SilentlyContinue\n        If (-not $CnameRecordPresent) {\n            $Counter ++\n            Write-Output 'CNAME record missing, creating it'\n            $HostNameAlias = \"$CompName.$FQDN\"\n            If ($DomainType -eq 'AWSManagedAD') {\n                Invoke-Command -Authentication 'CredSSP' -ComputerName $env:COMPUTERNAME -Credential $Credentials -ScriptBlock { Add-DnsServerResourceRecordCName -Name 'PKI' -ComputerName $using:DC -HostNameAlias $using:HostNameAlias -ZoneName $using:FQDN }\n            } Else {\n                Invoke-Command -ComputerName $DC -Credential $Credentials -ScriptBlock { Add-DnsServerResourceRecordCName -Name 'PKI' -HostNameAlias $using:HostNameAlias -ZoneName $using:FQDN }\n            }\n\n            If ($Counter -gt '1') {\n                Start-Sleep -Seconds 10\n            }\n        }\n    } Until ($CnameRecordPresent -or $Counter -eq 12)\n\n    If ($DomainType -eq 'AWSManagedAD') {  \n        Set-CredSSP -Action 'Disable'\n    }\n\n    If ($Counter -ge 12) {\n        Write-Output 'CNAME record never created'\n        Exit 1\n    }\n\n    Write-Output 'Creating PKI folders'\n    Foreach ($Folder in $Folders) {\n        $PathPresent = Test-Path -Path $Folder -ErrorAction SilentlyContinue\n        If (-not $PathPresent) {\n            Try {\n                $Null = New-Item -Path $Folder -Type 'Directory' -ErrorAction Stop\n            } Catch [System.Exception] {\n                Write-Output \"Failed to create $Folder directory $_\"\n                Exit 1\n            }\n        } \n    }\n\n    Write-Output 'Example CPS statement' | Out-File 'D:\\Pki\\cps.txt'\n\n    Write-Output 'Sharing PKI folder'\n    $SharePresent = Get-SmbShare -Name 'Pki' -ErrorAction SilentlyContinue\n    If (-not $SharePresent) {\n        Try {\n            $Null = New-SmbShare -Name 'Pki' -Path 'D:\\Pki' -FullAccess 'SYSTEM', \"$Netbios\\Domain Admins\" -ChangeAccess \"$Netbios\\Cert Publishers\" -ErrorAction Stop\n        } Catch [System.Exception] {\n            Write-Output \"Failed to create PKI SMB Share $_\"\n            Exit 1\n        }\n    }\n\n    Write-Output 'Creating PKI IIS virtual directory'\n    $VdPresent = Get-WebVirtualDirectory -Name 'Pki'\n    If (-not $VdPresent) {\n        Try {\n            $Null = New-WebVirtualDirectory -Site 'Default Web Site' -Name 'Pki' -PhysicalPath 'D:\\Pki' -ErrorAction Stop\n        } Catch [System.Exception] {\n            Write-Output \"Failed to create PKI IIS virtual directory $_\"\n            Exit 1\n        }\n    }\n\n    Write-Output 'Setting PKI IIS virtual directory requestFiltering'\n    Try {\n        Set-WebConfigurationProperty -Filter '/system.webServer/security/requestFiltering' -Name 'allowDoubleEscaping' -Value 'true' -PSPath 'IIS:\\Sites\\Default Web Site\\Pki' -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed to set PKI IIS virtual directory requestFiltering $_\"\n        Exit 1\n    }\n\n    Write-Output 'Setting PKI IIS virtual directory directoryBrowse'\n    Try {\n        Set-WebConfigurationProperty -Filter '/system.webServer/directoryBrowse' -Name 'enabled' -Value 'true' -PSPath 'IIS:\\Sites\\Default Web Site\\Pki' -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed to set PKI IIS virtual directory directoryBrowse $_\"\n        Exit 1\n    }\n\n    Write-Output 'Setting PKI folder file system ACLs'\n    Foreach ($Princ in $Principals) {\n        $Principal = New-Object -TypeName 'System.Security.Principal.NTAccount'($Princ)\n        $Perms = [System.Security.AccessControl.FileSystemRights]'Read, ReadAndExecute, ListDirectory'\n        $Inheritance = [System.Security.AccessControl.InheritanceFlags]::'ContainerInherit', 'ObjectInherit'\n        $Propagation = [System.Security.AccessControl.PropagationFlags]::'None'\n        $Access = [System.Security.AccessControl.AccessControlType]::'Allow'\n        $AccessRule = New-Object -TypeName 'System.Security.AccessControl.FileSystemAccessRule'($Principal, $Perms, $Inheritance, $Propagation, $Access) \n        Try {\n            $Acl = Get-Acl -Path $FilePath -ErrorAction Stop\n        } Catch [System.Exception] {\n            Write-Output \"Failed to get ACL for PKI directory $_\"\n            Exit 1\n        }\n        $Acl.AddAccessRule($AccessRule)\n        Try {\n            Set-Acl -Path $FilePath -AclObject $Acl -ErrorAction Stop\n        } Catch [System.Exception] {\n            Write-Output \"Failed to set ACL for PKI directory $_\"\n            Exit 1\n        }\n    }\n\n    Write-Output 'Resetting IIS service'\n    Try {\n        & iisreset.exe > $null\n    } Catch [System.Exception] {\n        Write-Output \"Failed to reset IIS service $_\"\n        Exit 1\n    }\n\n    $URL = \"URL=http://$CompName.$FQDN/pki/cps.txt\"\n\n    $Inf = @(\n        '[Version]',\n        'Signature=\"$Windows NT$\"',\n        '[PolicyStatementExtension]',\n        'Policies=InternalPolicy',\n        '[InternalPolicy]',\n        'OID=1.2.3.4.1455.67.89.5', \n        'Notice=\"Legal Policy Statement\"',\n        $URL\n        '[Certsrv_Server]',\n        \"RenewalKeyLength=$EntCaKeyLength\",\n        'RenewalValidityPeriod=Years',\n        \"RenewalValidityPeriodUnits=$EntCaValidityPeriodUnits\",\n        'CRLPeriod=Weeks',\n        'CRLPeriodUnits=1',\n        'CRLDeltaPeriod=Days',  \n        'CRLDeltaPeriodUnits=0',\n        'LoadDefaultTemplates=0',\n        'AlternateSignatureAlgorithm=0',\n        '[CRLDistributionPoint]',\n        '[AuthorityInformationAccess]'\n    )\n\n    Write-Output 'Creating CAPolicy.inf'\n    Try {\n        $Inf | Out-File -FilePath 'C:\\Windows\\CAPolicy.inf' -Encoding 'ascii'\n    } Catch [System.Exception] {\n        Write-Output \"Failed to create CAPolicy.inf $_\"\n        Exit 1\n    }\n\n    Write-Output 'Installing Enterprise Root CA'\n    Try {\n        $Null = Install-AdcsCertificationAuthority -CAType 'EnterpriseRootCA' -CACommonName $EntCaCommonName -KeyLength $EntCaKeyLength -HashAlgorithm $EntCaHashAlgorithm -CryptoProviderName 'RSA#Microsoft Software Key Storage Provider' -ValidityPeriod 'Years' -ValidityPeriodUnits $EntCaValidityPeriodUnits -DatabaseDirectory 'D:\\ADCS\\DB' -LogDirectory 'D:\\ADCS\\Log' -Force -ErrorAction Stop -Credential $Credentials\n    } Catch [System.Exception] {\n        Write-Output \"Failed to install Enterprise Root CA $_\"\n        Exit 1\n    }\n\n    $CDP = \"http://$CompName.$FQDN/pki/<CaName><CRLNameSuffix><DeltaCRLAllowed>.crl\"\n    $AIA = \"http://$CompName.$FQDN/pki/<ServerDNSName>_<CaName><CertificateName>.crt\"\n\n    Write-Output 'Configuring CRL distro points'\n    Try {\n        $Null = Get-CACRLDistributionPoint | Where-Object { $_.Uri -like '*ldap*' -or $_.Uri -like '*http*' -or $_.Uri -like '*file*' } -ErrorAction Stop | Remove-CACRLDistributionPoint -Force -ErrorAction Stop\n        $Null = Add-CACRLDistributionPoint -Uri $CDP -AddToCertificateCDP -Force -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed to configure CRL Distro $_\"\n        Exit 1\n    }\n\n    Write-Output 'Configuring AIA distro points'\n    Try {\n        $Null = Get-CAAuthorityInformationAccess | Where-Object { $_.Uri -like '*ldap*' -or $_.Uri -like '*http*' -or $_.Uri -like '*file*' } -ErrorAction Stop | Remove-CAAuthorityInformationAccess -Force -ErrorAction Stop\n        $Null = Add-CAAuthorityInformationAccess -AddToCertificateAia -Uri $AIA -Force -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed to configure AIA Distro $_\"\n        Exit 1\n    }\n\n    Write-Output 'Configuring Enterprise CA'\n    & certutil.exe -setreg CA\\CRLOverlapPeriodUnits '12' > $null\n    & certutil.exe -setreg CA\\CRLOverlapPeriod 'Hours' > $null\n    & certutil.exe -setreg CA\\ValidityPeriodUnits '5' > $null\n    & certutil.exe -setreg CA\\ValidityPeriod 'Years' > $null\n    & certutil.exe -setreg CA\\AuditFilter '127' > $null\n    & auditpol.exe /set /subcategory:'Certification Services' /failure:enable /success:enable > $null\n\n    Write-Output 'Restarting CA service'\n    Try {\n        Restart-Service -Name 'certsvc' -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed to restart CA service $_\"\n        Exit 1\n    }\n\n    Start-Sleep -Seconds 10\n\n    Write-Output 'Publishing CRL'\n    & certutil.exe -crl > $null\n\n    Write-Output 'Copying CRL to PKI folder'\n    Try {\n        Copy-Item -Path 'C:\\Windows\\System32\\CertSrv\\CertEnroll\\*.cr*' -Destination 'D:\\Pki\\' -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed to copy CRL to PKI folder  $_\"\n        Exit 1\n    }\n\n    Write-Output 'Restarting CA service'\n    Try {\n        Restart-Service -Name 'certsvc' -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed to restart CA service $_\"\n    }\n\n    Write-Output 'Creating LdapOverSSL certificate template'\n    New-KerbCertTemplate -BaseDn $BaseDn -Credential $Credentials -Server $DC\n\n    If ($DomainType -eq 'SelfManagedAD') {  \n        Write-Output 'Getting domain controllers'\n        Try {\n            $DomainControllers = Get-ADComputer -SearchBase \"OU=Domain Controllers,$BaseDn\" -Filter * | Select-Object -ExpandProperty 'DNSHostName'\n        } Catch [System.Exception] {\n            Write-Output \"Failed to get domain controllers $_\"\n        }\n\n        Write-Output 'Running Group Policy update on all domain controllers'\n        Foreach ($DomainController in $DomainControllers) {\n            Invoke-Command -ComputerName $DomainController -Credential $Credentials -ScriptBlock { Invoke-GPUpdate -RandomDelayInMinutes '0' -Force }\n        }\n    }\n\n    Write-Output 'Creating Update CRL scheduled task'\n    Try {\n        $ScheduledTaskAction = New-ScheduledTaskAction -Execute 'PowerShell.exe' -Argument '& certutil.exe -crl; Copy-Item -Path C:\\Windows\\System32\\CertSrv\\CertEnroll\\*.cr* -Destination D:\\Pki\\'\n        $ScheduledTaskTrigger = New-ScheduledTaskTrigger -Daily -DaysInterval '5' -At '12am' -ErrorAction Stop\n        $ScheduledTaskPrincipal = New-ScheduledTaskPrincipal -UserId 'SYSTEM' -LogonType 'ServiceAccount' -RunLevel 'Highest' -ErrorAction Stop\n        $ScheduledTaskSettingsSet = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -Compatibility 'Win8' -ExecutionTimeLimit (New-TimeSpan -Hours '1') -ErrorAction Stop\n        $ScheduledTask = New-ScheduledTask -Action $ScheduledTaskAction -Principal $ScheduledTaskPrincipal -Trigger $ScheduledTaskTrigger -Settings $ScheduledTaskSettingsSet -Description 'Updates CRL to Local Pki Folder' -ErrorAction Stop\n        $Null = Register-ScheduledTask 'Update CRL' -InputObject $ScheduledTask -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed to register Update CRL scheduled task $_\"\n    }\n\n    Write-Output 'Running CRL scheduled task'\n    Try {\n        Start-ScheduledTask -TaskName 'Update CRL' -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed to run CRL scheduled task $_\"\n    }\n\n    Write-Output 'Restarting CA service'\n    Try {\n        Restart-Service -Name 'certsvc' -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed to restart CA service $_\"\n    }\n\n    Write-Output 'Setting Windows Firewall WinRM Public rule to allow VPC CIDR traffic'\n    Try {\n        Set-NetFirewallRule -Name 'WINRM-HTTP-In-TCP-PUBLIC' -RemoteAddress $VPCCIDR -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed to allow WinRM traffic from VPC CIDR $_\"\n    }\n}\n\nFunction Set-CredSSP {\n    [CmdletBinding()]\n    param(\n        [Parameter(Mandatory = $true)][ValidateSet('Enable', 'Disable')][string]$Action\n    )\n\n    $RootKey = 'HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows'\n    $CredDelKey = 'CredentialsDelegation'\n    $FreshCredKey = 'AllowFreshCredentials'\n    $FreshCredKeyNTLM = 'AllowFreshCredentialsWhenNTLMOnly'\n\n    Switch ($Action) {\n        'Enable' {\n            Write-Output 'Enabling CredSSP'\n            $CredDelKeyPresent = Test-Path -Path (Join-Path -Path \"Registry::$RootKey\" -ChildPath $CredDelKey) -ErrorAction SilentlyContinue\n            If (-not $CredDelKeyPresent) {\n                Write-Output \"Setting CredSSP registry entry $CredDelKey\"\n                Try {\n                    $CredDelPath = New-Item -Path \"Registry::$RootKey\" -Name $CredDelKey -ErrorAction Stop | Select-Object -ExpandProperty 'Name'\n                } Catch [System.Exception] {\n                    Write-Output \"Failed to create CredSSP registry entry $CredDelKey $_\"\n                    Remove-Item -Path (Join-Path -Path \"Registry::$RootKey\" -ChildPath $CredDelKey) -Force -Recurse\n                    Exit 1\n                }\n            } Else {\n                $CredDelPath = Join-Path -Path $RootKey -ChildPath $CredDelKey\n            }\n\n            $FreshCredKeyPresent = Test-Path -Path (Join-Path -Path \"Registry::$CredDelPath\" -ChildPath $FreshCredKey) -ErrorAction SilentlyContinue\n            If (-not $FreshCredKeyPresent) {\n                Write-Output \"Setting CredSSP registry entry $FreshCredKey\"\n                Try {\n                    $FreshCredKeyPath = New-Item -Path \"Registry::$CredDelPath\" -Name $FreshCredKey -ErrorAction Stop | Select-Object -ExpandProperty 'Name'\n                } Catch [System.Exception] {\n                    Write-Output \"Failed to create CredSSP registry entry $FreshCredKey $_\"\n                    Remove-Item -Path (Join-Path -Path \"Registry::$RootKey\" -ChildPath $CredDelKey) -Force -Recurse\n                    Exit 1\n                }\n            } Else {\n                $FreshCredKeyPath = Join-Path -Path $CredDelPath -ChildPath $FreshCredKey\n            }\n\n            $FreshCredKeyNTLMPresent = Test-Path -Path (Join-Path -Path \"Registry::$CredDelPath\" -ChildPath $FreshCredKeyNTLM) -ErrorAction SilentlyContinue\n            If (-not $FreshCredKeyNTLMPresent) {\n                Write-Output \"Setting CredSSP registry entry $FreshCredKeyNTLM\"\n                Try {\n                    $FreshCredKeyNTLMPath = New-Item -Path \"Registry::$CredDelPath\" -Name $FreshCredKeyNTLM -ErrorAction Stop | Select-Object -ExpandProperty 'Name'\n                } Catch [System.Exception] {\n                    Write-Output \"Failed to create CredSSP registry entry $FreshCredKeyNTLM $_\"\n                    Remove-Item -Path (Join-Path -Path \"Registry::$RootKey\" -ChildPath $CredDelKey) -Force -Recurse\n                    Exit 1\n                }\n            } Else {\n                $FreshCredKeyNTLMPath = Join-Path -Path $CredDelPath -ChildPath $FreshCredKeyNTLM\n            }\n\n            Try {\n                $Null = Set-ItemProperty -Path \"Registry::$CredDelPath\" -Name 'AllowFreshCredentials' -Value '1' -Type 'Dword' -Force -ErrorAction Stop\n                $Null = Set-ItemProperty -Path \"Registry::$CredDelPath\" -Name 'ConcatenateDefaults_AllowFresh' -Value '1' -Type 'Dword' -Force -ErrorAction Stop\n                $Null = Set-ItemProperty -Path \"Registry::$CredDelPath\" -Name 'AllowFreshCredentialsWhenNTLMOnly' -Value '1' -Type 'Dword' -Force -ErrorAction Stop\n                $Null = Set-ItemProperty -Path \"Registry::$CredDelPath\" -Name 'ConcatenateDefaults_AllowFreshNTLMOnly' -Value '1' -Type 'Dword' -Force -ErrorAction Stop\n                $Null = Set-ItemProperty -Path \"Registry::$FreshCredKeyPath\" -Name '1' -Value 'WSMAN/*' -Type 'String' -Force -ErrorAction Stop\n                $Null = Set-ItemProperty -Path \"Registry::$FreshCredKeyNTLMPath\" -Name '1' -Value 'WSMAN/*' -Type 'String' -Force -ErrorAction Stop\n            } Catch [System.Exception] {\n                Write-Output \"Failed to create CredSSP registry properties $_\"\n                Remove-Item -Path (Join-Path -Path \"Registry::$RootKey\" -ChildPath $CredDelKey) -Force -Recurse\n                Exit 1\n            }\n\n            Try {\n                $Null = Enable-WSManCredSSP -Role 'Client' -DelegateComputer '*' -Force -ErrorAction Stop\n                $Null = Enable-WSManCredSSP -Role 'Server' -Force -ErrorAction Stop\n            } Catch [System.Exception] {\n                Write-Output \"Failed to enable CredSSP $_\"\n                $Null = Disable-WSManCredSSP -Role 'Client' -ErrorAction SilentlyContinue\n                $Null = Disable-WSManCredSSP -Role 'Server' -ErrorAction SilentlyContinue\n                Exit 1\n            }\n        }\n        'Disable' {\n            Write-Output 'Disabling CredSSP'\n            Try {\n                Disable-WSManCredSSP -Role 'Client' -ErrorAction Continue\n                Disable-WSManCredSSP -Role 'Server' -ErrorAction Stop\n            } Catch [System.Exception] {\n                Write-Output \"Failed to disable CredSSP $_\"\n                Exit 1\n            }\n\n            Write-Output 'Removing CredSSP registry entries'\n            Try {\n                Remove-Item -Path (Join-Path -Path \"Registry::$RootKey\" -ChildPath $CredDelKey) -Force -Recurse -ErrorAction Stop\n            } Catch [System.Exception] {\n                Write-Output \"Failed to remove CredSSP registry entries $_\"\n                Exit 1\n            }\n        }\n        Default { \n            Write-Output 'InvalidArgument: Invalid value is passed for parameter Action'\n            Exit 1\n        }\n    }\n}\n\nFunction New-TemplateOID {\n    [CmdletBinding()]\n    param(\n        [Parameter(Mandatory = $true)][string]$Server,\n        [Parameter(Mandatory = $true)][string]$ConfigNC\n    )\n\n    $Hex = '0123456789ABCDEF'\n\n    Do {\n        [string]$RandomHex = $null\n        For ($i = 1; $i -le 32; $i++) {\n            $RandomHex += $Hex.Substring((Get-Random -Minimum 0 -Maximum 16), 1)\n        }\n\n        $OID_Part_1 = Get-Random -Minimum 1000000 -Maximum 99999999\n        $OID_Part_2 = Get-Random -Minimum 10000000 -Maximum 99999999\n        $OID_Part_3 = $RandomHex\n        $OID_Forest = Get-ADObject -Server $Server -Identity \"CN=OID,CN=Public Key Services,CN=Services,$ConfigNC\" -Properties msPKI-Cert-Template-OID | Select-Object -ExpandProperty msPKI-Cert-Template-OID -ErrorAction SilentlyContinue\n        $msPKICertTemplateOID = \"$OID_Forest.$OID_Part_1.$OID_Part_2\"\n        $Name = \"$OID_Part_2.$OID_Part_3\"\n        $Search = Get-ADObject -Server $Server -SearchBase \"CN=OID,CN=Public Key Services,CN=Services,$ConfigNC\" -Filter { cn -eq $Name -and msPKI-Cert-Template-OID -eq $msPKICertTemplateOID } -ErrorAction SilentlyContinue\n        If ($Search) { \n            $Unique = 'False'\n        } Else { \n            $Unique = 'True'\n        }\n    } Until ($Unique = 'True')\n    Return @{\n        TemplateOID  = $msPKICertTemplateOID\n        TemplateName = $Name\n    }\n}\n\nFunction New-KerbCertTemplate {\n    [CmdletBinding()]\n    param(\n        [Parameter(Mandatory = $true)][string]$BaseDn,\n        [Parameter(Mandatory = $true)][PSCredential]$Credential,\n        [Parameter(Mandatory = $true)][string]$Server\n    )\n\n    $CA = $env:COMPUTERNAME\n\n    $OID = New-TemplateOID -Server $Server -ConfigNC \"CN=Configuration,$BaseDn\"\n\n    $TemplateOIDPath = \"CN=OID,CN=Public Key Services,CN=Services,CN=Configuration,$BaseDn\"\n    $OidOtherAttributes = @{\n        'DisplayName'             = 'LdapOverSSL'\n        'flags'                   = [System.Int32]'1'\n        'msPKI-Cert-Template-OID' = $OID.TemplateOID\n    }\n\n    $OtherAttributes = @{\n        'flags'                                = [System.Int32]'131168'\n        'msPKI-Certificate-Application-Policy' = [Microsoft.ActiveDirectory.Management.ADPropertyValueCollection]@('1.3.6.1.5.2.3.5', '1.3.6.1.4.1.311.20.2.2', '1.3.6.1.5.5.7.3.1', '1.3.6.1.5.5.7.3.2')\n        'msPKI-Certificate-Name-Flag'          = [System.Int32]'138412032'\n        'msPKI-Enrollment-Flag'                = [System.Int32]'40'\n        'msPKI-Minimal-Key-Size'               = [System.Int32]'2048'\n        'msPKI-Private-Key-Flag'               = [System.Int32]'84279552'\n        'msPKI-Template-Minor-Revision'        = [System.Int32]'1'\n        'msPKI-Template-Schema-Version'        = [System.Int32]'4'\n        'msPKI-RA-Signature'                   = [System.Int32]'0'\n        'pKIMaxIssuingDepth'                   = [System.Int32]'0'\n        'ObjectClass'                          = [System.String]'pKICertificateTemplate'\n        'pKICriticalExtensions'                = [Microsoft.ActiveDirectory.Management.ADPropertyValueCollection]@('2.5.29.17', '2.5.29.15')\n        'pKIDefaultCSPs'                       = [Microsoft.ActiveDirectory.Management.ADPropertyValueCollection]@('1,Microsoft RSA SChannel Cryptographic Provider')\n        'pKIDefaultKeySpec'                    = [System.Int32]'1'\n        'pKIExpirationPeriod'                  = [System.Byte[]]@('0', '64', '57', '135', '46', '225', '254', '255')\n        'pKIExtendedKeyUsage'                  = [Microsoft.ActiveDirectory.Management.ADPropertyValueCollection]@('1.3.6.1.5.2.3.5', '1.3.6.1.4.1.311.20.2.2', '1.3.6.1.5.5.7.3.1', '1.3.6.1.5.5.7.3.2')\n        'pKIKeyUsage'                          = [System.Byte[]]@('160', '0')\n        'pKIOverlapPeriod'                     = [System.Byte[]]@('0', '128', '166', '10', '255', '222', '255', '255')\n        'revision'                             = [System.Int32]'100'\n        'msPKI-Cert-Template-OID'              = $OID.TemplateOID\n    }\n\n    Write-Output \"Creating new LdapOverSSL certificate template OID $_\"\n    Try {\n        New-ADObject -Path $TemplateOIDPath -OtherAttributes $OidOtherAttributes -Name $OID.TemplateName -Type 'msPKI-Enterprise-Oid' -Server $Server -Credential $Credential -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed to create new LdapOverSSL certificate template OID $_\"\n        Exit 1\n    }\n\n    $TemplatePath = \"CN=Certificate Templates,CN=Public Key Services,CN=Services,CN=Configuration,$BaseDn\"\n\n    Write-Output \"Creating new LdapOverSSL certificate template $_\"\n    Try {\n        New-ADObject -Path $TemplatePath -OtherAttributes $OtherAttributes -Name 'LdapOverSSL' -DisplayName 'LdapOverSSL' -Type 'pKICertificateTemplate' -Server $Server -Credential $Credential -ErrorAction Stop\n    } Catch [System.Exception] {\n        Write-Output \"Failed to create new LdapOverSSL certificate template $_\"\n        Exit 1\n    }\n\n    $SidsToAdd = @(\n        [Security.Principal.SecurityIdentifier]'S-1-5-9'\n        (Get-ADGroup -Identity 'Domain Controllers' | Select-Object -ExpandProperty 'SID')\n    )\n\n    $SidsToRemove = @(\n        [Security.Principal.SecurityIdentifier]'S-1-5-18',\n        (Get-ADGroup -Identity 'Domain Admins' | Select-Object -ExpandProperty 'SID')\n    )\n\n    Set-CredSSP -Action 'Enable'\n\n    Write-Output 'Sleeping to ensure replication of certificate template has completed'\n    Start-Sleep -Seconds 60\n\n    Write-Output 'Cleaning up ACLs on LdapOverSSL certificate template'\n    $ExtendedRightGuids = @(\n        [GUID]'0e10c968-78fb-11d2-90d4-00c04f79dc55',\n        [GUID]'a05b8cc2-17bc-4802-a710-e7c15ab866a2'\n    )\n    Foreach ($SidToAdd in $SidsToAdd) {\n        Add-CertTemplateAcl -Credential $Credential -Path \"CN=LdapOverSSL,CN=Certificate Templates,CN=Public Key Services,CN=Services,CN=Configuration,$BaseDn\" -IdentityReference $SidToAdd -ActiveDirectoryRights 'GenericRead,GenericWrite,WriteDacl,WriteOwner,Delete' -AccessControlType 'Allow' -ActiveDirectorySecurityInheritance 'None'\n\n        Foreach ($ExtendedRightGuid in $ExtendedRightGuids) {\n            Add-CertTemplateAcl -Credential $Credential -Path \"CN=LdapOverSSL,CN=Certificate Templates,CN=Public Key Services,CN=Services,CN=Configuration,$BaseDn\" -IdentityReference $SidToAdd -ActiveDirectoryRights 'ExtendedRight' -AccessControlType 'Allow' -ObjectGuid $ExtendedRightGuid -ActiveDirectorySecurityInheritance 'None'\n        }\n    }\n\n    Set-CertTemplateAclInheritance -Credential $Credential -Path \"CN=LdapOverSSL,CN=Certificate Templates,CN=Public Key Services,CN=Services,CN=Configuration,$BaseDn\"\n\n    Foreach ($SidToRemove in $SidsToRemove) {\n        Remove-CertTemplateAcl -Credential $Credential -Path \"CN=LdapOverSSL,CN=Certificate Templates,CN=Public Key Services,CN=Services,CN=Configuration,$BaseDn\" -IdentityReference $SidToRemove -AccessControlType 'Allow'\n    }\n\n    Write-Output \"Publishing LdapOverSSL template to allow enrollment\"\n    $Counter = 0\n    Do {\n        $TempPresent = $Null\n        Try {\n            $TempPresent = Invoke-Command -Authentication 'Credssp' -ComputerName $env:COMPUTERNAME -Credential $Credential -ScriptBlock { \n                Get-ADObject \"CN=$Using:CA,CN=Enrollment Services,CN=Public Key Services,CN=Services,CN=Configuration,$Using:BaseDn\" -Partition \"CN=Configuration,$Using:BaseDn\" -Properties 'certificateTemplates' | Select-Object -ExpandProperty 'certificateTemplates' | Where-Object { $_ -contains 'LdapOverSSL' }\n            }\n        } Catch [System.Exception] {\n            Write-Output \"LdapOverSSL Template missing\"\n            $TempPresent = $Null\n        }\n        If (-not $TempPresent) {\n            $Counter ++\n            Write-Output \"LdapOverSSL Template missing adding it.\"\n            Try {\n                Invoke-Command -Authentication 'Credssp' -ComputerName $env:COMPUTERNAME -Credential $Credential -ScriptBlock {\n                    Set-ADObject \"CN=$Using:CA,CN=Enrollment Services,CN=Public Key Services,CN=Services,CN=Configuration,$Using:BaseDn\" -Partition \"CN=Configuration,$Using:BaseDn\" -Add @{ 'certificateTemplates' = 'LdapOverSSL' } \n                }\n            } Catch [System.Exception] {\n                Write-Output \"Failed to add publish LdapOverSSL template $_\"\n            }\n            If ($Counter -gt '1') {\n                Start-Sleep -Seconds 10\n            }\n        }\n    } Until ($TempPresent -or $Counter -eq 12)\n\n    Write-Output 'Sleeping to ensure replication of certificate template publish has completed'\n    Start-Sleep -Seconds 60\n\n    Set-CredSSP -Action 'Disable'\n}\n\nFunction Add-CertTemplateAcl {\n    [CmdletBinding()]\n    param(\n        [Parameter(Mandatory = $true)][PSCredential]$Credential,\n        [Parameter(Mandatory = $true)][string]$Path,\n        [Parameter(Mandatory = $true)][Security.Principal.SecurityIdentifier]$IdentityReference,\n        [Parameter(Mandatory = $true)][System.DirectoryServices.ActiveDirectoryRights]$ActiveDirectoryRights,\n        [Parameter(Mandatory = $true)][System.Security.AccessControl.AccessControlType]$AccessControlType,\n        [Parameter(Mandatory = $false)][Guid]$ObjectGuid,\n        [Parameter(Mandatory = $false)][System.DirectoryServices.ActiveDirectorySecurityInheritance]$ActiveDirectorySecurityInheritance,\n        [Parameter(Mandatory = $false)][Guid]$InheritedObjectGuid\n    )\n\n    Invoke-Command -Authentication 'Credssp' -ComputerName $env:COMPUTERNAME -Credential $Credential -ScriptBlock {\n        Import-Module -Name 'ActiveDirectory' -Force\n\n        [Security.Principal.SecurityIdentifier]$IdentityReference = $Using:IdentityReference | Select-Object -ExpandProperty 'Value'\n\n        $ArgumentList = $IdentityReference, $Using:ActiveDirectoryRights, $Using:AccessControlType, $Using:ObjectGuid, $Using:ActiveDirectorySecurityInheritance, $Using:InheritedObjectGuid\n        $ArgumentList = $ArgumentList.Where({ $_ -ne $Null })\n\n        Write-Output 'Creating ACL object'\n        Try {\n            $Rule = New-Object -TypeName 'System.DirectoryServices.ActiveDirectoryAccessRule' -ArgumentList $ArgumentList -ErrorAction Stop\n        } Catch [System.Exception] {\n            Write-Output \"Failed to create ACL object $_\"\n            Exit 1\n        }\n\n        Write-Output \"Getting ACL for $Using:Path\"\n        Try {\n            $ObjectAcl = Get-Acl -Path \"AD:\\$Using:Path\" -ErrorAction Stop\n        } Catch [System.Exception] {\n            Write-Output \"Failed to get ACL for $Using:Path $_\"\n            Exit 1\n        }\n\n        $ObjectAcl.AddAccessRule($Rule) \n\n        Write-Output \"Setting ACL for $Using:Path\"\n        Try {\n            Set-Acl -AclObject $ObjectAcl -Path \"AD:\\$Using:Path\" -ErrorAction Stop\n        } Catch [System.Exception] {\n            Write-Output \"Failed to set ACL for $Using:Path $_\"\n            Exit 1\n        }\n    }\n}\n\nFunction Set-CertTemplateAclInheritance {\n    [CmdletBinding()]\n    param(\n        [Parameter(Mandatory = $true)][PSCredential]$Credential,\n        [Parameter(Mandatory = $true)][string]$Path\n    )\n\n    Invoke-Command -Authentication 'Credssp' -ComputerName $env:COMPUTERNAME -Credential $Credential -ScriptBlock {\n        Import-Module -Name 'ActiveDirectory' -Force -ErrorAction Stop\n\n        Write-Output \"Getting ACL for $Using:Path\"\n        Try {\n            $ObjectAcl = Get-Acl -Path \"AD:\\$Using:Path\" -ErrorAction Stop\n        } Catch [System.Exception] {\n            Write-Output \"Failed to get ACL for $Using:Path $_\"\n            Exit 1\n        }\n\n        $ObjectAcl.SetAccessRuleProtection($true, $false)\n\n        Write-Output \"Setting ACL for $Using:Path\"\n        Try {\n            Set-Acl -AclObject $ObjectAcl -Path \"AD:\\$Using:Path\" -ErrorAction Stop\n        } Catch [System.Exception] {\n            Write-Output \"Failed to set ACL for $Using:Path $_\"\n            Exit 1\n        }\n    }\n}\n\nFunction Remove-CertTemplateAcl {\n    [CmdletBinding()]\n    param(\n        [Parameter(Mandatory = $true)][PSCredential]$Credential,\n        [Parameter(Mandatory = $true)][string]$Path,\n        [Parameter(Mandatory = $true)][Security.Principal.SecurityIdentifier]$IdentityReference,\n        [Parameter(Mandatory = $true)][System.Security.AccessControl.AccessControlType]$AccessControlType\n    )\n\n    Invoke-Command -Authentication 'Credssp' -ComputerName $env:COMPUTERNAME -Credential $Credential -ScriptBlock {\n        Import-Module -Name 'ActiveDirectory' -Force -ErrorAction Stop\n\n        Write-Output \"Getting ACL for $Using:Path\"\n        Try {\n            $ObjectAcl = Get-Acl -Path \"AD:\\$Using:Path\" -ErrorAction Stop\n        } Catch [System.Exception] {\n            Write-Output \"Failed to get ACL for $Using:Path $_\"\n            Exit 1\n        }\n\n        [Security.Principal.SecurityIdentifier]$IdentityReference = $Using:IdentityReference | Select-Object -ExpandProperty 'Value'\n\n        $ObjectAcl.RemoveAccess($IdentityReference, $Using:AccessControlType)\n\n        Write-Output \"Removing ACL for $Using:Path\"\n        Try {\n            Set-Acl -AclObject $ObjectAcl -Path \"AD:\\$Using:Path\" -ErrorAction Stop\n        } Catch [System.Exception] {\n            Write-Output \"Failed to remove ACL for $Using:Path $_\"\n            Exit 1\n        }\n    }\n}\n\n$Secret = Get-SecretInfo -Domain '{{DomainNetBIOSName}}' -SecretArn '{{AdministratorSecretName}}'\n$DeploymentType = '{{DeploymentType}}'\n\nIf ($DeploymentType -eq 'EnterpriseCA' -or $DeploymentType -eq 'EnterpriseCAManagementInstance') {\n    Invoke-EnterpriseCaConfig -Credentials $Secret.DomainCredentials -DomainType '{{DomainType}}' -EntCaCommonName '{{ServerNetBIOSName}}' -EntCaHashAlgorithm 'SHA256' -EntCaKeyLength '2048' -EntCaValidityPeriodUnits '5' -VPCCIDR '{{VPCCIDR}}'\n}"
            },
            "CloudWatchOutputConfig": {
              "CloudWatchOutputEnabled": true,
              "CloudWatchLogGroupName": "/aws/SSM-Pki-${var.ssm_docs_random_string}"
            },
            "InstanceIds": [
              "{{InstanceId.InstanceId}}"
            ],
            "DocumentName": "AWS-RunPowerShellScript"
          },
          "name": "configureInstance",
          "action": "aws:runCommand"
        }
      ]
    }
DOC
}
