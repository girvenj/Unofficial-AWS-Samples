AWSTemplateFormatVersion: "2010-09-09"
Description: >-
  This template creates the following resources:
    1. (1) Amazon EC2 Instance Role & Profile with the appropriate permissions to run SSM Automation and Run Commands Documents as well as retrieve and rotate AD credential stored in Secrets Manager
    2. (1) Security Groups
      a. (1) Rotator-Security-Group
    3. (1) Amazon EC2 Instance (All t3.medium, 45Gb (C:) GP3) joined to Active Directory with AD mgmt. tools installed
    4. (2) SSM Documents
      a. (1) SSM Automation Document to configure the Amazon EC2 Instance
      b. (1) SSM Run Command Document rotate an AD credential stored in Secrets Manager
    5. (1) SSM Maintenance Windows to execute the SSM Run Command Document every 30 days against the Amazon EC2 Instance
Parameters:
  AMI:
    Default: /aws/service/ami-windows-latest/Windows_Server-2022-English-Core-Base
    Description: (Required) System Manager parameter value for latest Windows Server AMI
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
  DNSIP1:
    Description: (Required) IP Address the task instance will use for DNS resolution
    Type: String
  DNSIP2:
    Description: (Required) IP Address the task instance will use for DNS resolution
    Type: String
  DomainDNSName:
    AllowedPattern: ^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\.)+[a-zA-Z]{2,}$
    Default: onpremises.local
    Description: (Required) Fully qualified domain name (FQDN) of the AD domain e.g. onpremises.local
    MaxLength: "255"
    MinLength: "2"
    Type: String
  DomainNetBIOSName:
    AllowedPattern: ^[^\\/:*?"<>|.]+[^\\/:*?"<>|]*$
    Default: ONPREMISES
    Description: (Required) NetBIOS name of the AD domain (up to 15 characters) e.g. ONPREMISES
    MaxLength: "15"
    MinLength: "1"
    Type: String
  EbsKmsKey:
    Default: alias/aws/ebs
    Description: Alias for the KMS encryption key used to encrypt the EBS volume
    Type: String
  InstanceType:
    Default: t3.medium
    Description: (Required) EC2 Instance type used for task instance
    Type: String
  RotatedAccountSecretArn:
    Description: (Required) ARN of Secret that contains credentials to be rotated
    Type: String
  RotatedAccountSecretKeyArn:
    Description: (Required) ARN of the KMS key used to encrypt the Secret that contains credentials to be rotated
    Type: String
  RotatedAccountSecretUserName:
    Default: RdsServiceAccount
    Description: (Required) Username of the credentials to be rotated
    Type: String
  RotatedAccountSecretUserNameKey:
    Default: CUSTOMER_MANAGED_ACTIVE_DIRECTORY_USERNAME
    Description: (Required) Secret username key of the credentials to be rotated
    Type: String
  RotatedAccountSecretUserPasswordKey:
    Default: CUSTOMER_MANAGED_ACTIVE_DIRECTORY_PASSWORD
    Description: (Required) Secret password key of the credentials to be rotated
    Type: String
  ServerNetBIOSName:
    Default: Rotator-RDS
    Description: (Required) Task instance NetBIOS name of the server (up to 15 characters)
    Type: String
  SetupAccountSecretArn:
    Description: (Required) Secret ARN for credentials used to domain join and configure the task instance
    Type: String
  SetupAccountSecretKeyArn:
    Description: (Required) ARN of the KMS key used to encrypt the Secret that contains credentials used to domain join and configure the task instance
    Type: String
  SubnetId:
    Description: ID of subnet where task instance will be deployed (e.g., subnet-1234597890abcdefg)
    Type: AWS::EC2::Subnet::Id
  VPCID:
    Description: ID of the VPC where task instance will be deployed (e.g., vpc-1234597890abcdefg)
    Type: AWS::EC2::VPC::Id
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Instance Parameters
        Parameters:
          - AMI
          - InstanceType
          - EbsKmsKey
          - SubnetId
          - VPCID
          - ServerNetBIOSName
      - Label:
          default: Active Directory Parameters
        Parameters:
          - DomainDNSName
          - DomainNetBIOSName
          - DNSIP1
          - DNSIP2
          - SetupAccountSecretArn
          - SetupAccountSecretKeyArn
      - Label:
          default: Rotated Account Parameters
        Parameters:
          - RotatedAccountSecretArn
          - RotatedAccountSecretKeyArn
          - RotatedAccountSecretUserName
          - RotatedAccountSecretUserNameKey
          - RotatedAccountSecretUserPasswordKey
    ParameterLabels:
      AMI:
        default: SSM Parameter for Latest AMI ID
      DNSIP1:
        default: Task Instance DNS Resolver IP 1
      DNSIP2:
        default: Task Instance DNS Resolver IP 2
      DomainDNSName:
        default: AD Domain DNS Name
      DomainNetBIOSName:
        default: AD Domain NetBIOS Name
      EbsKmsKey:
        default: EBS KMS Encryption Key
      InstanceType:
        default: EC2 Instance Type
      RotatedAccountSecretArn:
        default: Secret ARN for Credentials to be Rotated
      RotatedAccountSecretKeyArn:
        default: KMS Key ARN for Secret used for Rotated Credentials
      RotatedAccountSecretUserName:
        default: Credentials to be Rotated Username
      RotatedAccountSecretUserNameKey:
        default: Credentials to be Rotated Username Key
      RotatedAccountSecretUserPasswordKey:
        default: Credentials to be Rotated Password Key
      SetupAccountSecretArn:
        default: Secret ARN for Configuration Credentials
      SetupAccountSecretKeyArn:
        default: KMS Key ARN for Secret used for Configuration Credentials
      ServerNetBIOSName:
        default: Task Instance NetBIOS Name
      SubnetId:
        default: Task Instance Subnet ID
      VPCID:
        default: Task Instance VPC ID
Resources:
  InstanceRole:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: This is by design as they are read permissions only
          - id: W28
            reason: This is by design to be least privilege
          - id: W76
            reason: This is by design to be least privilege
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - ec2.amazonaws.com
        Version: "2012-10-17"
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
        - !Sub arn:${AWS::Partition}:iam::aws:policy/CloudWatchAgentServerPolicy
      Path: /
      Policies:
        - PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Action:
                  - kms:CreateGrant
                  - kms:Decrypt
                  - kms:DescribeKey
                  - kms:GenerateDataKey
                Effect: Allow
                Resource:
                  - !Ref RotatedAccountSecretKeyArn
                  - !Ref SetupAccountSecretKeyArn
              - Action:
                  - secretsmanager:DescribeSecret
                  - secretsmanager:GetSecretValue
                  - secretsmanager:UpdateSecret
                Resource:
                  - !Ref RotatedAccountSecretArn
                Effect: Allow
              - Action: cloudformation:SignalResource
                Effect: Allow
                Resource: !Sub arn:${AWS::Partition}:cloudformation:${AWS::Region}:${AWS::AccountId}:stack/${AWS::StackName}/*
              - Action:
                  - secretsmanager:GetSecretValue
                  - secretsmanager:DescribeSecret
                Effect: Allow
                Resource:
                  - !Ref SetupAccountSecretArn
              - Action: ssm:SendCommand
                Effect: Allow
                Resource:
                  - !Sub arn:${AWS::Partition}:ssm:${AWS::Region}:*:document/AWS-RunRemoteScript
                  - !Sub arn:${AWS::Partition}:ssm:${AWS::Region}:*:document/AWS-RunPowerShellScript
              - Action: ssm:SendCommand
                Condition:
                  StringEquals:
                    "ssm:ResourceTag/aws:cloudformation:stack-name": !Ref AWS::StackName
                Effect: Allow
                Resource: !Sub arn:${AWS::Partition}:ec2:${AWS::Region}:${AWS::AccountId}:instance/*
              - Action: ssm:StartAutomationExecution
                Effect: Allow
                Resource:
                  - !Sub arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:automation-definition/${SetupSsmAuto}:$DEFAULT
              - Action:
                  - ec2:DescribeInstances
                  - ssm:DescribeInstanceInformation
                  - ssm:GetAutomationExecution
                  - ssm:ListCommands
                  - ssm:ListCommandInvocations
                Effect: Allow
                Resource: "*"
          PolicyName: !Sub Inline-Policy-${AWS::StackName}
      RoleName: !Sub Instance-Role-${AWS::StackName}
      Tags:
        - Key: StackName
          Value:
            Ref: AWS::StackName
  InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      InstanceProfileName: !Sub Instance-Role-${AWS::StackName}
      Path: /
      Roles:
        - Ref: InstanceRole
  RotatorSG:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W5
            reason: This is by design to ensure this instance has the proper SG.
          - id: W28
            reason: This is by design to ensure this instance has the proper SG.
          - id: W40
            reason: This is by design to ensure this instance has the proper SG.
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: !Sub Rotator-Security-Group-${AWS::StackName}
      GroupName: !Sub Rotator-Security-Group-${AWS::StackName}
      SecurityGroupEgress:
        - Description: All Outbound Traffic
          FromPort: -1
          IpProtocol: "-1"
          CidrIp: 0.0.0.0/0
          ToPort: -1
      Tags:
        - Key: Name
          Value: !Sub Rotator-Security-Group-${AWS::StackName}
      VpcId: !Ref VPCID
  SetupSsmAuto:
    Type: AWS::SSM::Document
    Properties:
      Content:
        schemaVersion: "0.3"
        description: Deploy Seamless Domain Join Password Rotation Instance with SSM Automation
        parameters:
          DNSIP1:
            description: Task instance DNS resolver IP 1
            type: String
          DNSIP2:
            description: Task instance DNS resolver IP 2
            type: String
          DomainDNSName:
            description: AD domain DNS name
            type: String
          DomainNetBIOSName:
            description: AD domain NetBIOS name
            type: String
          RotatedAccountSecretUserName:
            description: Username for service account to be rotated
            type: String
          RotatedAccountSecretKeyArn:
            description: ARN of KMS Key used to encrypt Secret containing credentials to be rotated
            type: String
          RotatorInstanceRole:
            description: ARN of instance role attached to rotator instance
            type: String
          ServerNetBIOSName:
            description: Task instance NetBIOS name
            type: String
          SetupAccountSecretArn:
            description: Secret ARN for configuration credentials
            type: String
          SetupAccountSecretKeyArn:
            description: ARN of KMS Key used to encrypt Secret containing configuration credentials
            type: String
          StackName:
            description: CloudFormation Stack Name
            type: String
        mainSteps:
          - name: InstanceId
            action: aws:executeAwsApi
            onFailure: step:Signalfailure
            nextStep: Setup
            inputs:
              Service: ec2
              Api: DescribeInstances
              Filters:
                - Name: tag:Name
                  Values:
                    - "{{ServerNetBIOSName}}"
                - Name: tag:aws:cloudformation:stack-name
                  Values:
                    - "{{StackName}}"
                - Name: instance-state-name
                  Values:
                    - running
            outputs:
              - Name: InstanceId
                Selector: "$.Reservations[0].Instances[0].InstanceId"
                Type: String
          - name: Setup
            action: aws:runCommand
            onFailure: step:Signalfailure
            nextStep: Domainjoin
            inputs:
              DocumentName: AWS-RunPowerShellScript
              InstanceIds:
                - "{{InstanceId.InstanceId}}"
              CloudWatchOutputConfig:
                CloudWatchOutputEnabled: true
                CloudWatchLogGroupName: !Sub /aws/Rotator/${AWS::StackName}
              Parameters:
                commands:
                  - |
                    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

                    $Keys = @(
                      '{{RotatedAccountSecretKeyArn}}',
                      '{{SetupAccountSecretKeyArn}}'
                    )
                    Foreach ($Key in $Keys) {
                        Try {
                            $KeyManager = Get-KMSKey -KeyId $Key | Select-Object -ExpandProperty 'KeyManager' | Select-Object -ExpandProperty 'Value'
                        } Catch [System.Exception] {
                            Write-Output "Failed to get KMS Key. $_"
                            Exit 1
                        }

                        If ($KeyManager -eq 'CUSTOMER') {
                            Try {
                                $Null = New-KMSGrant -GranteePrincipal '{{RotatorInstanceRole}}' -KeyId $Key -Name 'Rotator-Instance-Grant' -Operation 'Decrypt', 'GenerateDataKey' -Force
                            } Catch [System.Exception] {
                                Write-Output "Failed to grant rotator instance role to KMS Key. $_"
                                Exit 1
                            }
                        }
                    }

                    $RegistryItems = @(
                      @{
                          Name         = 'SchUseStrongCrypto'
                          Path         = 'Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework\v4.0.30319'
                          Value        = '1'
                          PropertyType = 'DWORD'
                      },
                      @{
                          Name         = 'SchUseStrongCrypto'
                          Path         = 'Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\.NETFramework\v4.0.30319'
                          Value        = '1'
                          PropertyType = 'DWORD'
                      },
                      @{
                        Name         = 'HideFirstRunExperience'
                        Path         = 'Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Edge'
                        Value        = '1'
                        PropertyType = 'DWORD'
                      }
                    )

                    Foreach ($RegistryItem in $RegistryItems) {
                        $KeyPresent = Test-Path -Path $RegistryItem.Path -ErrorAction SilentlyContinue
                        If (-not $KeyPresent) {
                            Try {
                                $Null = New-Item -Path $RegistryItem.Path -Force -ErrorAction Stop
                            } Catch [System.Exception] {
                                Write-Output "Failed to create Registry named $($RegistryItem.Path) $_"
                                Exit 1
                            }
                        }
                        Try {
                            $Null = New-ItemProperty @RegistryItem -Force -ErrorAction Stop
                        } Catch [System.Exception] {
                            Write-Output "Failed to create Registry key named $($RegistryItem.Name) at $($RegistryItem.Path) $_"
                            Exit 1
                        }
                    }

                    $Modules = @(
                        @{
                            Name    = 'ComputerManagementDsc'
                            Version = '8.5.0'
                        },
                        @{
                            Name    = 'NetworkingDsc'
                            Version = '9.0.0'
                        },
                        @{
                            Name    = 'PSReadline'
                            Version = '2.2.6'
                        }
                    )

                    Function Invoke-PreConfig {
                        $Dirs = @(
                            'C:\Temp\publickeys'
                        )

                        Foreach ($Dir in $Dirs) {
                            Write-Output "Creating file directory $Dir"
                            Try {
                                $Null = New-Item -Path $Dir -ItemType 'Directory' -ErrorAction Stop
                            } Catch [System.Exception] {
                                Write-Output "Failed to create directory $Dir $_"
                                Exit 1
                            }
                        }

                        Write-Output 'Creating certificate to encrypt credentials in MOF file'
                        Try {
                            $cert = New-SelfSignedCertificate -Type 'DocumentEncryptionCertLegacyCsp' -DnsName 'DscEncryptCert' -HashAlgorithm 'SHA256' -ErrorAction Stop
                        } Catch [System.Exception] {
                            Write-Output "Failed to create self signed cert $_"
                            Exit 1
                        }

                        Try {
                            $Null = $cert | Export-Certificate -FilePath 'C:\Temp\publickeys\DscPublicKey.cer' -Force -ErrorAction Stop
                        } Catch [System.Exception] {
                            Write-Output "Failed to copy self signed cert to publickeys directory $_"
                            Exit 1
                        }
                    }

                    Function Invoke-LcmConfig {
                        Try {
                            $DscCertThumbprint = Get-ChildItem -Path 'cert:\LocalMachine\My' -ErrorAction Stop | Where-Object { $_.Subject -eq 'CN=DscEncryptCert' } | Select-Object -ExpandProperty 'Thumbprint'
                        } Catch [System.Exception] {
                            Write-Output "Failed to get DSC cert thumbprint $_"
                            Exit 1
                        }

                        [DSCLocalConfigurationManager()]
                        Configuration LCMConfig
                        {
                            Node 'localhost' {
                                Settings {
                                    RefreshMode                    = 'Push'
                                    ConfigurationModeFrequencyMins = 15
                                    ActionAfterReboot              = 'StopConfiguration'
                                    RebootNodeIfNeeded             = $false
                                    ConfigurationMode              = 'ApplyAndAutoCorrect'
                                    CertificateId                  = $DscCertThumbprint
                                }
                            }
                        }

                        Write-Output 'Generating MOF file for LCM and set LCM configuration'
                        $Null = LCMConfig -OutputPath 'C:\Temp\LCMConfig'

                        Try {
                            Set-DscLocalConfigurationManager -Path 'C:\Temp\LCMConfig' -ErrorAction Stop
                        } Catch [System.Exception] {
                            Write-Output "Failed to set LCM configuration $_"
                            Exit 1
                        }
                    }

                    Write-Output 'Installing NuGet Package Provider'
                    Try {
                        $Null = Install-PackageProvider -Name 'NuGet' -MinimumVersion '2.8.5' -Force -ErrorAction Stop
                    } Catch [System.Exception] {
                        Write-Output "Failed to install NuGet package provider $_"
                        Exit 1
                    }

                    Write-Output 'Setting PSGallery Respository to trusted'
                    Try {
                        Set-PSRepository -Name 'PSGallery' -InstallationPolicy 'Trusted' -ErrorAction Stop
                    } Catch [System.Exception] {
                        Write-Output "Failed to set PSGallery respository to trusted $_"
                        Exit 1
                    }

                    Write-Output 'Installing the needed Powershell DSC modules'
                    Foreach ($Module in $Modules) {
                        Try {
                            Install-Module -Name $Module.Name -RequiredVersion $Module.Version -ErrorAction Stop
                        } Catch [System.Exception] {
                            Write-Output "Failed to import modules $_"
                            Exit 1
                        }
                    }

                    Invoke-PreConfig
                    Invoke-LcmConfig
          - name: Domainjoin
            action: aws:runCommand
            onFailure: step:Signalfailure
            nextStep: InvokeCleanup
            inputs:
              DocumentName: AWS-RunPowerShellScript
              InstanceIds:
                - "{{InstanceId.InstanceId}}"
              CloudWatchOutputConfig:
                CloudWatchOutputEnabled: true
                CloudWatchLogGroupName: !Sub /aws/Rotator/${AWS::StackName}
              Parameters:
                commands:
                  - |
                    Function Get-SecretInfo {
                        [CmdletBinding()]
                        Param (
                            [Parameter(Mandatory = $True)][String]$Domain,
                            [Parameter(Mandatory = $True)][String]$SecretArn
                        )

                        Try {
                            $SecretContent = Get-SECSecretValue -SecretId $SecretArn -ErrorAction Stop | Select-Object -ExpandProperty 'SecretString' | ConvertFrom-Json -ErrorAction Stop
                        } Catch [System.Exception] {
                            Write-Output "Failed to get $SecretArn Secret $_"
                            Exit 1
                        }

                        $Username = $SecretContent.username
                        $UserPassword = ConvertTo-SecureString ($SecretContent.password) -AsPlainText -Force
                        $DomainCredentials = New-Object -TypeName 'System.Management.Automation.PSCredential' ("$Domain\$Username", $UserPassword)
                        $Credentials = New-Object -TypeName 'System.Management.Automation.PSCredential' ($Username, $UserPassword)

                        $Output = [PSCustomObject][Ordered]@{
                            'Credentials'       = $Credentials
                            'DomainCredentials' = $DomainCredentials
                            'Username'          = $Username
                            'UserPassword'      = $UserPassword
                        }

                        Return $Output
                    }

                    Function Get-EniConfig {
                        Try {
                            $NetIpConfig = Get-NetIPConfiguration -ErrorAction Stop
                        } Catch [System.Exception] {
                            Write-Output "Failed to get network configuration $_"
                            Exit 1
                        }

                        $GatewayAddress = $NetIpConfig | Select-Object -ExpandProperty 'IPv4DefaultGateway' | Select-Object -ExpandProperty 'NextHop'

                        $IpAddress = $NetIpConfig | Select-Object -ExpandProperty 'IPv4Address' | Select-Object -ExpandProperty 'IpAddress'
                        $Prefix = $NetIpConfig | Select-Object -ExpandProperty 'IPv4Address' | Select-Object -ExpandProperty 'PrefixLength'
                        $InterfaceAlias = $NetIpConfig | Select-Object -ExpandProperty 'InterfaceAlias'
                        $IpAddr = 'IP/CIDR' -replace 'IP', $IpAddress -replace 'CIDR', $Prefix

                        $Count = 0
                        Do {
                            Try {
                                $NetAdapter = Get-NetAdapter -ErrorAction SilentlyContinue
                            } Catch [System.Exception] {
                                Write-Output "Failed to get NIC information"
                            }
                            $Count ++
                            If ($Count -gt '1') {
                                Start-Sleep -Seconds 10
                            }
                        } Until ($NetAdapter.Status -eq 'Up' -or $Count -ge 12)

                        If ($Count -ge 12) {
                            Write-Output 'NIC status never went active'
                            Exit 1
                        }

                        $MacAddress = $NetAdapter | Select-Object -ExpandProperty 'MacAddress'

                        $Output = [PSCustomObject][Ordered]@{
                            'GatewayAddress' = $GatewayAddress
                            'IpAddress'      = $IpAddr
                            'DnsIpAddress'   = $IpAddress
                            'MacAddress'     = $MacAddress
                            'InterfaceAlias' = $InterfaceAlias
                        }

                        Return $Output
                    }

                    Function Set-DscConfiguration {
                        [CmdletBinding()]
                        param(
                            [Parameter(Mandatory = $true)][PSCredential]$DaCredentials,
                            [Parameter(Mandatory = $true)][String[]]$DnsIps,
                            [Parameter(Mandatory = $true)][string]$DomainDNSName,
                            [Parameter(Mandatory = $true)][string]$DomainNetBIOSName,
                            [Parameter(Mandatory = $true)][string]$GatewayAddress,
                            [Parameter(Mandatory = $true)][string]$InstanceIP,
                            [Parameter(Mandatory = $true)][string]$InstanceNetBIOSName,
                            [Parameter(Mandatory = $true)][string]$MacAddress
                        )

                        Try {
                            $DscCertThumbprint = Get-ChildItem -Path 'cert:\LocalMachine\My' -ErrorAction Stop | Where-Object { $_.Subject -eq 'CN=DscEncryptCert' } | Select-Object -ExpandProperty 'Thumbprint'
                        } Catch [System.Exception] {
                            Write-Output "Failed to get DSC cert thumbprint $_"
                            Exit 1
                        }

                        $ConfigurationData = @{
                            AllNodes = @(
                                @{
                                    NodeName             = '*'
                                    CertificateFile      = 'C:\Temp\publickeys\DscPublicKey.cer'
                                    Thumbprint           = $DscCertThumbprint
                                    PSDscAllowDomainUser = $true
                                },
                                @{
                                    NodeName = 'localhost'
                                }
                            )
                        }

                        Configuration ConfigInstance {
                            Import-DscResource -ModuleName 'PSDesiredStateConfiguration', 'NetworkingDsc', 'ComputerManagementDsc'
                            Node LocalHost {
                                NetAdapterName RenameNetAdapterPrimary {
                                    NewName    = 'Primary'
                                    MacAddress = $MacAddress
                                }
                                PowerPlan SetPlanHighPerformance {
                                    IsSingleInstance = 'Yes'
                                    Name             = 'High performance'
                                }
                                NetAdapterAdvancedProperty JumboPacket {
                                    NetworkAdapterName = 'Primary'
                                    RegistryKeyword    = '*JumboPacket'
                                    RegistryValue      = 9015
                                    DependsOn          = '[NetAdapterName]RenameNetAdapterPrimary'
                                }
                                NetAdapterAdvancedProperty ReceiveBuffers {
                                    NetworkAdapterName = 'Primary'
                                    RegistryKeyword    = '*ReceiveBuffers'
                                    RegistryValue      = 8192
                                    DependsOn          = '[NetAdapterName]RenameNetAdapterPrimary'
                                }
                                NetAdapterAdvancedProperty TransmitBuffers {
                                    NetworkAdapterName = 'Primary'
                                    RegistryKeyword    = '*TransmitBuffers'
                                    RegistryValue      = 1024
                                    DependsOn          = '[NetAdapterName]RenameNetAdapterPrimary'
                                }
                                NetBios DisableNetBios {
                                    InterfaceAlias = 'Primary'
                                    Setting        = 'Disable'
                                }
                                DnsServerAddress DnsServerAddress {
                                    Address        = $DnsIps
                                    InterfaceAlias = 'Primary'
                                    AddressFamily  = 'IPv4'
                                    DependsOn      = '[NetAdapterName]RenameNetAdapterPrimary'
                                }
                                DnsConnectionSuffix DnsConnectionSuffix {
                                    InterfaceAlias                 = 'Primary'
                                    ConnectionSpecificSuffix       = $DomainDNSName
                                    RegisterThisConnectionsAddress = $True
                                    UseSuffixWhenRegistering       = $False
                                    DependsOn                      = '[DnsServerAddress]DnsServerAddress'
                                }
                                WindowsFeature RSAT-AD-PowerShell {
                                    Ensure    = 'Present'
                                    Name      = 'RSAT-AD-PowerShell'
                                    DependsOn = '[DnsConnectionSuffix]DnsConnectionSuffix'
                                }
                                WindowsFeature RSAT-AD-Tools {
                                  Ensure = 'Present'
                                  Name = 'RSAT-AD-Tools'
                                  DependsOn = '[DnsConnectionSuffix]DnsConnectionSuffix'
                                }
                                Computer JoinDomain {
                                    Name       = $InstanceNetBIOSName
                                    DomainName = $DomainDnsName
                                    Credential = $DaCredentials
                                    DependsOn  = '[WindowsFeature]RSAT-AD-PowerShell'
                                }
                            }
                        }
                        Write-Output 'Generating MOF file'
                        $Null = ConfigInstance -OutputPath 'C:\Temp\ConfigInstance' -ConfigurationData $ConfigurationData
                    }

                    Function Invoke-DscStatusCheck {
                        $LCMState = Get-DscLocalConfigurationManager -ErrorAction SilentlyContinue | Select-Object -ExpandProperty 'LCMState'
                        If ($LCMState -eq 'PendingConfiguration' -Or $LCMState -eq 'PendingReboot') {
                            Exit 3010
                        } Else {
                            Write-Output 'DSC configuration completed'
                        }
                    }

                    $Secret = Get-SecretInfo -Domain '{{DomainNetBIOSName}}' -SecretArn '{{SetupAccountSecretArn}}'
                    $EniConfig = Get-EniConfig

                    Set-DscConfiguration -DaCredentials $Secret.DomainCredentials -DnsIps '{{DNSIP1}}', '{{DNSIP2}}' -DomainDNSName '{{DomainDNSName}}' -DomainNetBIOSName '{{DomainNetBIOSName}}' -GatewayAddress $EniConfig.GatewayAddress -InstanceIP $EniConfig.IpAddress -InstanceNetBIOSName '{{ServerNetBIOSName}}' -MacAddress $EniConfig.MacAddress

                    Start-DscConfiguration 'C:\Temp\ConfigInstance' -Wait -Verbose -Force
                    Invoke-DscStatusCheck
          - name: InvokeCleanup
            action: aws:runCommand
            onFailure: step:Signalfailure
            inputs:
              DocumentName: AWS-RunPowerShellScript
              InstanceIds:
                - "{{InstanceId.InstanceId}}"
              CloudWatchOutputConfig:
                CloudWatchOutputEnabled: true
                CloudWatchLogGroupName: !Sub /aws/Rotator/${AWS::StackName}
              Parameters:
                commands:
                  - |
                    Function Invoke-Cleanup {
                        Write-Output 'Removing DSC Configuration'
                        Try {
                            Remove-DscConfigurationDocument -Stage 'Current' -ErrorAction Stop
                        } Catch [System.Exception] {
                            Write-Output "Failed build DSC Configuration $_"
                        }

                        Write-Output 'Re-enabling Windows Firewall'
                        Try {
                            Get-NetFirewallProfile -ErrorAction Stop | Set-NetFirewallProfile -Enabled 'True' -ErrorAction Stop
                        } Catch [System.Exception] {
                            Write-Output "Failed re-enable firewall $_"
                        }

                        Write-Output 'Removing build files'
                        Try {
                            Remove-Item -Path 'C:\Temp' -Recurse -Force -ErrorAction Stop
                        } Catch [System.Exception] {
                            Write-Output "Failed remove build files $_"
                        }

                        Write-Output 'Removing self signed cert'
                        Try {
                            $SelfSignedThumb = Get-ChildItem -Path 'cert:\LocalMachine\My\' -ErrorAction Stop | Where-Object { $_.Subject -eq 'CN=DscEncryptCert' } | Select-Object -ExpandProperty 'Thumbprint'
                            Remove-Item -Path "cert:\LocalMachine\My\$SelfSignedThumb" -DeleteKey -ErrorAction Stop
                        } Catch [System.Exception] {
                            Write-Output "Failed remove self signed cert $_"
                        }
                    }

                    Function Get-SecretInfo {
                        [CmdletBinding()]
                        Param (
                            [Parameter(Mandatory = $True)][String]$Domain,
                            [Parameter(Mandatory = $True)][String]$SecretArn
                        )

                        Try {
                            $SecretContent = Get-SECSecretValue -SecretId $SecretArn -ErrorAction Stop | Select-Object -ExpandProperty 'SecretString' | ConvertFrom-Json -ErrorAction Stop
                        } Catch [System.Exception] {
                            Write-Output "Failed to get $SecretArn Secret $_"
                            Exit 1
                        }

                        $Username = $SecretContent.username
                        $UserPassword = ConvertTo-SecureString ($SecretContent.password) -AsPlainText -Force
                        $DomainCredentials = New-Object -TypeName 'System.Management.Automation.PSCredential' ("$Domain\$Username", $UserPassword)
                        $Credentials = New-Object -TypeName 'System.Management.Automation.PSCredential' ($Username, $UserPassword)

                        $Output = [PSCustomObject][Ordered]@{
                            'Credentials'       = $Credentials
                            'DomainCredentials' = $DomainCredentials
                            'Username'          = $Username
                            'UserPassword'      = $UserPassword
                        }
                        Return $Output
                    }

                    Function Set-CredSSP {
                        [CmdletBinding()]
                        param(
                            [Parameter(Mandatory = $true)][ValidateSet('Enable', 'Disable')][string]$Action
                        )

                        $RootKey = 'HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows'
                        $CredDelKey = 'CredentialsDelegation'
                        $FreshCredKey = 'AllowFreshCredentials'
                        $FreshCredKeyNTLM = 'AllowFreshCredentialsWhenNTLMOnly'

                        Switch ($Action) {
                            'Enable' {
                                Write-Output 'Enabling CredSSP'
                                $CredDelKeyPresent = Test-Path -Path (Join-Path -Path "Registry::$RootKey" -ChildPath $CredDelKey) -ErrorAction SilentlyContinue
                                If (-not $CredDelKeyPresent) {
                                    Write-Output "Setting CredSSP registry entry $CredDelKey"
                                    Try {
                                        $CredDelPath = New-Item -Path "Registry::$RootKey" -Name $CredDelKey -ErrorAction Stop | Select-Object -ExpandProperty 'Name'
                                    } Catch [System.Exception] {
                                        Write-Output "Failed to create CredSSP registry entry $CredDelKey $_"
                                        Remove-Item -Path (Join-Path -Path "Registry::$RootKey" -ChildPath $CredDelKey) -Force -Recurse
                                        Exit 1
                                    }
                                } Else {
                                    $CredDelPath = Join-Path -Path $RootKey -ChildPath $CredDelKey
                                }

                                $FreshCredKeyPresent = Test-Path -Path (Join-Path -Path "Registry::$CredDelPath" -ChildPath $FreshCredKey) -ErrorAction SilentlyContinue
                                If (-not $FreshCredKeyPresent) {
                                    Write-Output "Setting CredSSP registry entry $FreshCredKey"
                                    Try {
                                        $FreshCredKeyPath = New-Item -Path "Registry::$CredDelPath" -Name $FreshCredKey -ErrorAction Stop | Select-Object -ExpandProperty 'Name'
                                    } Catch [System.Exception] {
                                        Write-Output "Failed to create CredSSP registry entry $FreshCredKey $_"
                                        Remove-Item -Path (Join-Path -Path "Registry::$RootKey" -ChildPath $CredDelKey) -Force -Recurse
                                        Exit 1
                                    }
                                } Else {
                                    $FreshCredKeyPath = Join-Path -Path $CredDelPath -ChildPath $FreshCredKey
                                }

                                $FreshCredKeyNTLMPresent = Test-Path -Path (Join-Path -Path "Registry::$CredDelPath" -ChildPath $FreshCredKeyNTLM) -ErrorAction SilentlyContinue
                                If (-not $FreshCredKeyNTLMPresent) {
                                    Write-Output "Setting CredSSP registry entry $FreshCredKeyNTLM"
                                    Try {
                                        $FreshCredKeyNTLMPath = New-Item -Path "Registry::$CredDelPath" -Name $FreshCredKeyNTLM -ErrorAction Stop | Select-Object -ExpandProperty 'Name'
                                    } Catch [System.Exception] {
                                        Write-Output "Failed to create CredSSP registry entry $FreshCredKeyNTLM $_"
                                        Remove-Item -Path (Join-Path -Path "Registry::$RootKey" -ChildPath $CredDelKey) -Force -Recurse
                                        Exit 1
                                    }
                                } Else {
                                    $FreshCredKeyNTLMPath = Join-Path -Path $CredDelPath -ChildPath $FreshCredKeyNTLM
                                }

                                Try {
                                    $Null = Set-ItemProperty -Path "Registry::$CredDelPath" -Name 'AllowFreshCredentials' -Value '1' -Type 'Dword' -Force -ErrorAction Stop
                                    $Null = Set-ItemProperty -Path "Registry::$CredDelPath" -Name 'ConcatenateDefaults_AllowFresh' -Value '1' -Type 'Dword' -Force -ErrorAction Stop
                                    $Null = Set-ItemProperty -Path "Registry::$CredDelPath" -Name 'AllowFreshCredentialsWhenNTLMOnly' -Value '1' -Type 'Dword' -Force -ErrorAction Stop
                                    $Null = Set-ItemProperty -Path "Registry::$CredDelPath" -Name 'ConcatenateDefaults_AllowFreshNTLMOnly' -Value '1' -Type 'Dword' -Force -ErrorAction Stop
                                    $Null = Set-ItemProperty -Path "Registry::$FreshCredKeyPath" -Name '1' -Value 'WSMAN/*' -Type 'String' -Force -ErrorAction Stop
                                    $Null = Set-ItemProperty -Path "Registry::$FreshCredKeyNTLMPath" -Name '1' -Value 'WSMAN/*' -Type 'String' -Force -ErrorAction Stop
                                } Catch [System.Exception] {
                                    Write-Output "Failed to create CredSSP registry properties $_"
                                    Remove-Item -Path (Join-Path -Path "Registry::$RootKey" -ChildPath $CredDelKey) -Force -Recurse
                                    Exit 1
                                }

                                Try {
                                    $Null = Enable-WSManCredSSP -Role 'Client' -DelegateComputer '*' -Force -ErrorAction Stop
                                    $Null = Enable-WSManCredSSP -Role 'Server' -Force -ErrorAction Stop
                                } Catch [System.Exception] {
                                    Write-Output "Failed to enable CredSSP $_"
                                    $Null = Disable-WSManCredSSP -Role 'Client' -ErrorAction SilentlyContinue
                                    $Null = Disable-WSManCredSSP -Role 'Server' -ErrorAction SilentlyContinue
                                    Exit 1
                                }
                            }
                            'Disable' {
                                Write-Output 'Disabling CredSSP'
                                Try {
                                    Disable-WSManCredSSP -Role 'Client' -ErrorAction Continue
                                    Disable-WSManCredSSP -Role 'Server' -ErrorAction Stop
                                } Catch [System.Exception] {
                                    Write-Output "Failed to disable CredSSP $_"
                                    Exit 1
                                }

                                Write-Output 'Removing CredSSP registry entries'
                                Try {
                                    Remove-Item -Path (Join-Path -Path "Registry::$RootKey" -ChildPath $CredDelKey) -Force -Recurse -ErrorAction Stop
                                } Catch [System.Exception] {
                                    Write-Output "Failed to remove CredSSP registry entries $_"
                                    Exit 1
                                }
                            }
                            Default { 
                                Write-Output 'InvalidArgument: Invalid value is passed for parameter Action'
                                Exit 1
                            }
                        }
                    }

                    $Secret = Get-SecretInfo -Domain '{{DomainDNSName}}'' -SecretArn '{{SetupAccountSecretArn}}
                    $ComputerName = $env:COMPUTERNAME
                    $ServiceAccount = '{{RotatedAccountSecretUserName}}'

                    Set-CredSSP -Action 'Enable'

                    Invoke-Command -Authentication 'Credssp' -ComputerName $env:COMPUTERNAME -Credential $Secret.Credentials -ScriptBlock {
                        Function Set-RotationAcls {
                            [CmdletBinding()]
                            Param (
                                [String]$ComputerAccount,
                                [String]$ServiceAccount
                            )
                            
                            #Requires -Modules 'ActiveDirectory'

                            Write-Output "Getting DN for $ServiceAccount."
                            Try {
                                $AccountPath = Get-ADUser -Identity $ServiceAccount -ErrorAction Stop | Select-Object -ExpandProperty 'DistinguishedName'
                            } Catch [System.Exception] {
                                Return "Unable to get DN for $ServiceAccount. $_"
                            }

                            Write-Output 'Getting RootDSE.'
                            Try {
                                $ErNamingContexts = Get-ADRootDSE -ErrorAction Stop | Select-Object -ExpandProperty 'ConfigurationNamingContext'
                            } Catch [System.Exception] {
                                Return "Unable to get RootDSE. $_"
                            }

                            Write-Output 'Getting GUID for User-Force-Change-Password.'
                            Try {
                                [System.GUID]$ErNamingContextGuid = Get-ADObject -SearchBase $ErNamingContexts -Filter { Name -eq 'User-Force-Change-Password' } -Properties 'rightsGuid' -ErrorAction Stop | Select-Object -ExpandProperty 'rightsGuid'
                            } Catch [System.Exception] {
                                Return "Unable to get GUID for User-Force-Change-Password. $_"
                            }

                            $NullGuid = [System.Guid]::empty

                            Write-Output "Getting $ComputerAccount details."
                            Try {
                                $ComputerAccount = Get-ADComputer -Identity $ComputerAccount -ErrorAction Stop | Select-Object -ExpandProperty 'SID' | Select-Object -ExpandProperty 'Value'
                                $ComputerAccountSid = New-Object -TypeName 'System.Security.Principal.SecurityIdentifier' $ComputerAccount -ErrorAction Stop
                            } Catch [System.Exception] {
                                Return "Unable to get $ComputerAccount details. $_"
                            }

                            Write-Output "Getting ACL for $ServiceAccount."
                            Try {
                                $ObjectAcl = Get-ACL -Path "AD:\$AccountPath" -ErrorAction Stop
                            } Catch [System.Exception] {
                                Return "Unable to get ACL for $ServiceAccount. $_"
                            }

                            Write-Output "Setting ACL allowing User-Force-Change-Password by $ComputerAccount on $ServiceAccount."
                            Try {
                                $AddAccessRule = New-Object -TypeName 'System.DirectoryServices.ActiveDirectoryAccessRule' $ComputerAccountSid, 'ExtendedRight', 'Allow', $ErNamingContextGuid, 'None', $NullGuid -ErrorAction Stop
                                $ObjectAcl.AddAccessRule($AddAccessRule)
                                Set-ACL -AclObject $ObjectAcl -Path "AD:\$AccountPath" -ErrorAction Stop
                            } Catch [System.Exception] {
                                Return "Unable to set ACL allowing User-Force-Change-Password by $ComputerAccount on $ServiceAccount. $_"
                            }
                        }
                        Set-RotationAcls -ComputerAccount $Using:Computername -ServiceAccount $Using:ServiceAccount
                    }

                    Set-CredSSP -Action 'Disable'

                    Invoke-Cleanup
          - name: CFNSignalEnd
            action: aws:branch
            inputs:
              Choices:
                - NextStep: Signalsuccess
                  Not:
                    Variable: "{{StackName}}"
                    StringEquals: ""
                - NextStep: Sleepend
                  Variable: "{{StackName}}"
                  StringEquals: ""
          - name: Signalsuccess
            action: aws:executeAwsApi
            isEnd: True
            inputs:
              Service: cloudformation
              Api: SignalResource
              LogicalResourceId: RotatorInstance
              StackName: "{{StackName}}"
              Status: SUCCESS
              UniqueId: "{{InstanceId.InstanceId}}"
          - name: Sleepend
            action: aws:sleep
            isEnd: True
            inputs:
              Duration: PT1S
          - name: Signalfailure
            action: aws:executeAwsApi
            inputs:
              Service: cloudformation
              Api: SignalResource
              LogicalResourceId: RotatorInstance
              StackName: "{{StackName}}"
              Status: FAILURE
              UniqueId: "{{InstanceId.InstanceId}}"
      DocumentType: Automation
      Name: !Sub Rotator-Build-Document-${AWS::StackName}
      Tags:
        - Key: StackName
          Value:
            Ref: AWS::StackName
  RotatorSsmAuto:
    Type: AWS::SSM::Document
    Properties:
      Content:
        schemaVersion: "2.2"
        description: Secret password rotation with AD
        parameters:
          RotatedAccountSecretArn:
            description: Secret ARN for Credentials to be Rotated
            type: String
          RotatedAccountSecretUserName:
            description: Credentials to be Rotated Username
            type: String
          RotatedAccountSecretUserNameKey:
            description: Credentials to be Rotated Username Key
            type: String
          RotatedAccountSecretUserPasswordKey:
            description: Credentials to be Rotated Password Key
            type: String
        mainSteps:
          - action: aws:runPowerShellScript
            name: example
            inputs:
              runCommand:
                - |
                  Function Invoke-PasswordRotation {
                      [CmdletBinding()]
                      Param (
                          [String]$SecretARN,
                          [String]$SecretUserName,
                          [String]$SecretUserNameKey,
                          [String]$SecretUserPasswordKey
                      )
                      Write-Output "Attempting to rotate credentials stored in Secret $SecretARN"
                      $Region = $SecretARN.split(':')[3]
                      Try {
                          $SecretContent = Get-SECSecretValue -SecretId $SecretARN -Select 'SecretString' -Region $Region -ErrorAction Stop | Convertfrom-Json
                      } Catch [System.Exception] {
                          Write-Output "Failed to get Secret for domain join $_"
                          Exit 1
                      }
                      $OldSecretUserName = $SecretContent.$SecretUserNameKey
                      $OldSecretUserPW = $SecretContent.$SecretUserPasswordKey
                      Add-Type -AssemblyName "System.Web" -ErrorAction Stop
                      $MinLength = 64
                      $MaxLength = 128
                      $Length = Get-Random -Minimum $MinLength -Maximum $MaxLength -ErrorAction Stop
                      $NonAlphaChars = 10
                      $SecretUserPW = [System.Web.Security.Membership]::GeneratePassword($Length, $NonAlphaChars)
                      $SecretContent.$SecretUserNameKey = $SecretUserName
                      $SecretContent.$SecretUserPasswordKey = $SecretUserPW
                      Try {
                          Update-SECSecret -SecretId $SecretARN -SecretString ($SecretContent | ConvertTo-Json) -Region $Region -ErrorAction Stop
                      } Catch [System.Exception] {
                          Write-Output "Failed to update Secret, reverting Secret to old password $_"
                          $SecretContent.$SecretUserNameKey = $SecretUserName
                          $SecretContent.$SecretUserPasswordKey = $SecretUserPW
                          Update-SECSecret -SecretId $SecretARN -SecretString ($SecretContent | ConvertTo-Json) -Region $Region -ErrorAction Stop
                          Exit 1
                      }
                      Try {
                          Set-ADAccountPassword -Identity $SecretUserName -Reset -NewPassword ($SecretUserPW | ConvertTo-SecureString -asPlainText -Force) -OldPassword ($OldSecretUserPW | ConvertTo-SecureString -asPlainText -Force) -ErrorAction Stop
                      } Catch [System.Exception] {
                          Write-Output "Failed to update AD account reverting Secret to old password $_"
                          $SecretContent.$SecretUserNameKey = $OldSecretUserName
                          $SecretContent.$SecretUserPasswordKey = $OldSecretUserPW
                          Update-SECSecret -SecretId $SecretARN -SecretString ($SecretContent | ConvertTo-Json) -Region $Region -ErrorAction Stop
                          Exit 1
                      }
                      Write-Output "Successfully rotated credentials stored in Secret $SecretARN"
                  }
                  Invoke-PasswordRotation -SecretARN '{{RotatedAccountSecretArn}}' -SecretUserName '{{RotatedAccountSecretUserName}}' -SecretUserNameKey '{{RotatedAccountSecretUserNameKey}}' -SecretUserPasswordKey '{{RotatedAccountSecretUserPasswordKey}}'
      DocumentType: Command
      Name: !Sub Rotator-Document-${AWS::StackName}
      Tags:
        - Key: StackName
          Value:
            Ref: AWS::StackName
  RotatorInstance:
    Type: AWS::EC2::Instance
    CreationPolicy:
      ResourceSignal:
        Count: 1
        Timeout: PT60M
    Properties:
      BlockDeviceMappings:
        - DeviceName: /dev/sda1
          Ebs:
            DeleteOnTermination: true
            Encrypted: true
            KmsKeyId: !Ref EbsKmsKey
            VolumeSize: 45
            VolumeType: gp3
      IamInstanceProfile: !Ref InstanceProfile
      ImageId: !Ref AMI
      InstanceType: !Ref InstanceType
      SecurityGroupIds:
        - !Ref RotatorSG
      SubnetId: !Ref SubnetId
      Tags:
        - Key: Domain
          Value: !Ref DomainDNSName
        - Key: Name
          Value: !Ref ServerNetBIOSName
        - Key: Role
          Value: !Sub "Password Rotator for ${RotatedAccountSecretUserName}"
      UserData:
        Fn::Base64: !Sub |
          <powershell>
          $Params = @{
              DNSIP1 ='${DNSIP1}'
              DNSIP2 ='${DNSIP2}'
              DomainDNSName = '${DomainDNSName}'
              DomainNetBIOSName = '${DomainNetBIOSName}'
              RotatedAccountSecretUserName = '${RotatedAccountSecretUserName}'
              RotatorInstanceRole = '${InstanceRole}'
              RotatedAccountSecretKeyArn = '${RotatedAccountSecretKeyArn}'
              ServerNetBIOSName = '${ServerNetBIOSName}'
              SetupAccountSecretArn = '${SetupAccountSecretArn}'
              SetupAccountSecretKeyArn = '${SetupAccountSecretKeyArn}'
              StackName = '${AWS::StackName}'
          }
          Start-SSMAutomationExecution -DocumentName '${SetupSsmAuto}' -Parameter $Params
          </powershell>
  AutomationAssociation:
    Type: AWS::SSM::Association
    Properties:
      ApplyOnlyAtCronInterval: false
      AssociationName: !Sub Rotator-Document-Association-${AWS::StackName}
      ComplianceSeverity: "MEDIUM"
      MaxConcurrency: 1
      MaxErrors: 1
      Name: !Ref RotatorSsmAuto
      Parameters:
        RotatedAccountSecretArn:
          - !Ref RotatedAccountSecretArn
        RotatedAccountSecretUserName:
          - !Ref RotatedAccountSecretUserName
        RotatedAccountSecretUserNameKey:
          - !Ref RotatedAccountSecretUserNameKey
        RotatedAccountSecretUserPasswordKey:
          - !Ref RotatedAccountSecretUserPasswordKey
      ScheduleExpression: rate(30 days)
      Targets:
        - Key: InstanceIds
          Values:
            - !Ref RotatorInstance
Outputs:
  RotatorInstanceID:
    Description: Rotator Instance ID
    Value: !Ref RotatorInstance
  RotatorInstancePrivateIP:
    Description: Rotator Instance Private IP
    Value: !GetAtt RotatorInstance.PrivateIp
  RotatorSGSGID:
    Description: Rotator Security Group ID
    Value: !Ref RotatorSG
